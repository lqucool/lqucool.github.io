<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LocalPositionEstimator]]></title>
    <url>%2F2018%2F03%2F14%2FLocalPositionEstimator%2F</url>
    <content type="text"><![CDATA[Sensorsinput: ax, ay, az (acceleration NED) states: px, py, pz ( position NED, m) vx, vy, vz ( vel NED, m/s) bx, by, bz ( accel bias, m/s^2) tz (terrain altitude, ASL, m) measurements: sonar: pz (measured dcos(phi)cos(theta)) baro: pz flow: vx, vy (flow is in body x, y frame) gps: px, py, pz, vx, vy, vz (flow is in body x, y frame) lidar: pz (actual measured dcos(phi)cos(theta)) vision: px, py, pz, vx, vy, vz mocap: px, py, pz land (detects when landed)): pz (always measures agl = 0) Continuous-time extended Kalman filterprediction \begin{align} &\dot{x}_{(+|-)} = A*x_{(-|-)} + B*u_{(+)} \\ &\dot{P}_{(+|-)} = A*P_{(-|-)}*A^T + B*R_{acc}*B^T + Q \end{align}correction \begin{align} &K_i = P_{(+|-)} * C^T * (C * P_{(+|-)} * C^T + R_{sensor})^{-1} \\ &x_{(+|+)} = x_{(+|-)} + K_i * (y_i - C_i * x_{(+|-)} ) \\ &P_{(+|+)} = (I - K_i * C) * P_{(+|-)} \end{align} detect distance sensors see which updates are available get new data update parameters is xy valid? is z valid? is terrain valid? check timeouts reinitialize x if necessary force P symmetry and reinitialize P if necessary Predict x: \left[ \begin{array}{cccc} x \\ y \\ z \\ vx \\ vy \\ vz \\ bx \\ by \\ bz \\ tz \\ \end{array} \right] \qquad u: \left[ \begin{array}{cccc} a_{x\_{ned}} \\ a_{y\_{ned}} \\ a_{z\_{ned}} \\ \end{array} \right] A: \left[ \begin{array}{cccc} 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & _{-R_{att(0,0)}} & _{-R_{att(0,1)}} & _{-R_{att(0,2)}} & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & _{-R_{att(1,0)}} & _{-R_{att(1,1)}} & _{-R_{att(1,2)}} & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & _{-R_{att(2,0)}} & _{-R_{att(2,1)}} & _{-R_{att(2,2)}} & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \end{array} \right] \qquad B: \left[ \begin{array}{cccc} 0 & 0 & 0 \\ 0 & 0 & 0 \\ 0 & 0 & 0 \\ 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \\ 0 & 0 & 0 \\ 0 & 0 & 0 \\ 0 & 0 & 0 \\ 0 & 0 & 0 \\ \end{array} \right] P: \left[ \begin{array}{cccc} 8 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 8 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 8 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0.18 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0.18 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0.18 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 1e^{-6} & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1e^{-6} & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1e^{-6} & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 8 \\ \end{array} \right] Q: \left[ \begin{array}{cccc} 0.01 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0.01 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0.01 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0.01 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0.01 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0.01 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 1e^{-6} & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1e^{-6} & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1e^{-6} & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & pt \\ \end{array} \right] R_{acc}: \left[ \begin{array}{cccc} 0 .12^2& 0 & 0 \\ 0 & 0.12^2 & 0 \\ 0 & 0 & 0.02^2 \\ \end{array} \right] \begin{align} &u = \_R\_att * a_{body} \\ &u(a_{z\_ned})= u(a_{z\_ned}) - 9.81 \end{align}update A: A(vx,bx) = -R_{att(0,0)} \\ A(vx,by) = -R_{att(0,1)} \\ ...integrate runge kutta 4th order: \begin{align} &h = dt\\ &k1 = A * x + B * u \\ &k2 = A * (x + k1 * h / 2) + B * u \\ &k3 = A * (x + k2 * h / 2) + B * u \\ &k4 = A * (x + k3) + B *u \\ &dx = (k1 + k2 * 2 + k3 * 2 + k4) * (h /6) \end{align}saturate bias: \begin{align} &bx = dx(bx) + x(bx) \\ &bx = BIAS\_MAX * bx / |bx| \\ &dx(bx) = bx - x(bx) \end{align}propagate: \begin{align} x &= x + dx \\ dP &= (A * P + P * A^T + B * R_{acc} * B^T + Q) * dt \\ P &= P + dP \end{align} Correct \begin{align} S\_I &= (C * P * C^T + R_{sensor})^{-1} \\ r &= y - C * x \\ K &= P * C^T *S\_I \\ dx &= K *r \\ x &= x + dx \\ P &= P - K * C * P \end{align}BaroCorrect \begin{align} y&: [z_{baro}] \\ R_{baro}&: [3.0^2] \\ C&: \left[ \begin{array}{cccc} 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \end{array} \right] \end{align}LidarCorrect \begin{align} y &: [z_{lidar}] \\ R_{lidar}& : [0.03^2] \\ C&: \left[ \begin{array}{cccc} 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & -1 \\ \end{array} \right] \\ y &= y * cos(euler(0)) * cos(euler(1)) \\ \end{align}FlowCorrectcomplement: pixel\_flow\_integral = \frac{v *dt } {h} * scale_h + scale_{gyro} * tan(gyro\_rate\_integral)) check for sane pitch/roll check for agl check quality calculate range to center of image for flow optical flow in x, y axis: \begin{align} &d = (x(z) - x(tz) ) * cos(euler(phi)) * euler(theta) \\ &flow\_x\_rad = pixel\_flow\_x\_integral * scale \\ &flow\_y\_rad = pixel\_flow\_y\_integral * scale \\ &dt\_flow = integration\_timespan / 1e6; \end{align}angular rotation in x, y axis: gyro\_x\_rad = high\_pass\_flt(gyro\_x\_rate\_integral) \\ gyro\_y\_rad = high\_pass\_flt(gyro\_y\_rate\_integral) \\compute velocities in body frame using ground distance: delta\_b = \left[ \begin{array}{cccc} +(flow\_y\_rad - gyro\_y\_rad) * d \\ -(flow\_x\_rad - gyro\_x\_rad) * d \\ 0 \end{array} \right] \\rotation of flow from body to nav frame: \begin{align} delta\_n &= R\_att * delta\_b \\ \end{align} y = \left[ \begin{array}{cccc} delta\_n(0) / dt\_flow \\ delta\_n(1) / dt\_flow \end{array} \right] \\ C = \left[ \begin{array}{cccc} 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \end{array} \right] \\ R_{flow} = \left[ \begin{array}{cccc} 0 & 0 \\ 0 & 0 \end{array} \right]polynomial noise model, found using least squares fit: p[5] = \{0.04005232f, -0.00656446f, -0.26265873f, 0.13686658f, -0.00397357f\} \\ h = x(z) - x(tz) \\ v = y.norm()compute polynomial value: \begin{align} flow\_vxy\_stddev &= p[0] *h + p[1] * h * h + p[2] * v * h + p[4] * v * h * h \\ \\ rotrate\_sq &= att.rollspeed * att.rolldspeed \\ &+ att.pitchspeed *att.pitchspeed \\ &+ att.yawspeed * att.yawspeed \\ \\ rot\_sq &= euler(0) *euler(0) + euler(1) * euler(1) \\ \\ R_{flow}(0,0) &= flow\_vxy\_stddev * flow\_vxy\_stddev \\ &+ LPE\_FLW\_R * LPE\_FLW\_R * rot\_sq\\ &+ LPE\_FLW\_RR * LPE\_FLW\_RR * rotrate\_sq \\ R_{flow}(1,1) &= R_{flow}(0,0) \\ \end{align}GpsCorrect:formulas according to: http://mathworld.wolfram.com/AzimuthalEquidistantProjection.html get the orgin pos： ref\_cos\_lat = cos (lat) \\ ref\_cos\_lat = cos (lat) x\_rad = x / R_{earth} \\ \quad \\ y\_rad = y / R_{earth} \\ \quad \\ c = \sqrt{x\_rad^2 + y\_rad^2} \\ \quad \\ lat\_rad = asin(cos(c) * ref\_sin(lat) +\frac{x\_rad * sin(c) * ref\_cos(lat)}{c}) \\ \quad \\ lon\_rad = ref\_lon\_rad + atan(\frac{y\_rad * sin(c)} {c * ref\_cos\_lat * cos\_c - x\_rad * ref\_sin\_lat * sin(c)}) \\ \quad \\ gpsLatOrigin = lat\_rad * 180 / \pi \\ \quad \\ gpsLonOrigin = lon\_rad * 180 / \pi ref\_lat = gpsLatOrigin \qquad ref\_lat = gpsLatOrigin \\ ref\_sin\_lat = sin(gpsLatOrigin) \qquad ref\_cos\_lat = cos(gpsLatOrigin) y_{global} = \left[ \begin{array}{cccc} lat*1e^{-7} \\ lon*1e^{-7} \\ alt *1e^{-3} \\ vel\_n\_m\_s \\ vel\_e\_m\_s \\ vel\_d\_m\_s \end{array} \right] \\ sin\_lat=sin(lat*1e^{-7} * \frac{\pi} {180} ) \\ cos\_lat=cos(lat*1e^{-7} * \frac{\pi} {180} ) \\ cos\_d\_lon = cos(lon\_rad - ref\_lon\_rad) \\ arg = ref\_sin\_lat * sin\_lat + ref\_cos\_lat * lat * cos \_d\_lon \\ c = acos(arg) \\ k = c / sin(c) \\ px = k * (ref\_cos_lat * sin\_lat - ref\_sin\_lat * cos\_lat * cos\_d\_lon) * R_{earth} \\ py = k * cos\_lat * sin(lon\_rad - ref\_lon\_rad) * R_{earth} \\ pz = alt - \_gpsAltOrigin y = \left[ \begin{array}{cccc} px \\ py \\ pz \\ vel\_n\_m\_s \\ vel\_e\_m\_s \\ vel\_d\_m\_s \end{array} \right] C = \left[ \begin{array}{cccc} 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\ \end{array} \right] \\ \qquad \\ \qquad \\ R = \left[ \begin{array}{cccc} 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 & 0 & 0 \\ 0 & 0 & 3^2 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0.25^2 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0.25^2 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0.25^2 \\ \end{array} \right] \\]]></content>
      <categories>
        <category>quadcopter</category>
      </categories>
      <tags>
        <tag>quadcopter</tag>
        <tag>position fusion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高度切换]]></title>
    <url>%2F2017%2F11%2F22%2F%E9%AB%98%E5%BA%A6%E5%88%87%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[高度控制时有两种模式，一种是地形跟随，另外一种就是地形突变时，飞行器高度不跟随地形改变。 地形跟随模式就直接用对地测距数据融合加计就可以了。 第二种模式的话就需要在测距数据发生突变的时候，切换到气压高度。但是切换的时候要进行数据对齐，并且在测距数据一定时间稳定的时候再切换回测距的高度。油门发生改变的时候，是直接对垂直方向进行控速的，所以这时候可以直接把高度和测距的高度对齐。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152void alt_check_valid(float alt_laser, float alt_baro, float vel_laser, float vel_baro)&#123; /* state: 转换状态 * 0: alt来源为激光 * 1: alt来源由激光切换到气压 * 2: alt来源由气压切换到激光 */ static char state = 0; static int num = 0; static float alt = 0; static float align = 0; static float laser_buf[20] = &#123;0.0f&#125;; static float baro_buf[20] = &#123;0.0f&#125;; static int count = 0; float vel = 0; for(int i = 0; i &lt; 19; i++)&#123; laser_buf[i] = laser_buf[i+1]; baro_buf[i] = baro_buf[i+1]; &#125; laser_buf[19] = alt_laser; baro_buf[19] = alt_baro; if(count &lt; 20) count++; if(count &gt;= 19)&#123; // 气压速度大于0.1m/s时视为非悬停状态，此时不做切换 // todo: 此值可能需要调整 if( abs((alt_laser - laser_buf[1]) - (alt_baro - baro_buf[1])) &gt; 0.05f )&#123; if( state != 1)&#123; align = alt - alt_baro; // 切换到气压数据前，记录气压的对齐值 &#125; state = 1; num = 0; &#125; else if( state == 1 )&#123; num++; if(num == 400)&#123; //满足1s内数据平稳才能切换回激光数据，防止某些条件下频繁切换 num = 0; state = 2; // 切换回激光数据 align = alt - alt_laser; &#125; &#125; &#125; switch(state)&#123; case 0 : alt = alt_laser; vel = vel_laser; break; //采用激光高度，不发生切换 case 1 : alt = alt_baro + align; vel = vel_baro; break; //切换为气压，并对齐 case 2 : alt = alt_laser + align; vel = vel_laser; break; //切换为激光，并对齐 default: break; &#125;&#125;]]></content>
      <categories>
        <category>quadcopter</category>
      </categories>
      <tags>
        <tag>quadcopter</tag>
        <tag>height control</tag>
        <tag>height</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加计震动滤波]]></title>
    <url>%2F2017%2F11%2F13%2F%E5%8A%A0%E8%AE%A1%E9%9C%87%E5%8A%A8%E6%BB%A4%E6%B3%A2%2F</url>
    <content type="text"><![CDATA[采集加计数据，400Hz保存到SD卡 Matlab分析采集到的数据的频谱，确定滤波器参数 生成IIR滤波器参数 C++实现并在飞控平台上测试 采集飞控上滤波后的数据并和Matlab上的滤波效果对比 Matlab设计IIR滤波器 注：Matlab生成IIR滤波器参数，飞控上使用C++实现，实现效果和Matlab设计效果一致。 ​ 截止频率不一定合适，后面单独会对电机震动频率做分析，调整截止频率。 生成参数 滤波前后频谱 滤波前后曲线 飞控上的滤波效果和matlab上滤波的效果是一致的，证明滤波算法没问题。 飞控上滤波后的数据和Matlab滤波后曲线 飞控上滤波后的数据和Matlab滤波后频谱 ​ 电机震动对加计影响 电机震动引起的震动频率在20Hz ~ 30Hz之间，设置截止频率为10Hz，也不一定每一架飞机的震动频率都相同，具体测试吧。 Matlab分析数据曲线和数据频谱 滤波后效果 Matlab123456789101112131415161718192021222324252627282930313233343536373839% ············电机震动分析············% 截取起飞前的一段数据v4 = v4(9200:10000);plot(v4);hold on;% IIRFs=400; % 采样率 Hzn=2; % 阶数 Fp=10; % 通带截止频率 HzWn=Fp*2/Fs; [Bb,Ba]=butter(n,Wn,'low') % 调用MATLAB butter函数快速设计滤波器 [BH,BW]=freqz(Bb,Ba);Bf=filter(Bb,Ba,v4);plot(Bf);legend('滤波前','滤波后');title('电机转动时加计数据'); figure;% fft 滤波前n = size(v4,1)-1;Y = fft(v4, n);Ayy = (abs(Y));Ayy = Ayy / (n / 2);Ayy(1) = Ayy(1) / 2;F=(1:n - 1)*Fs/n;plot(F(1:n/2),Ayy(1:n/2));hold on;% fft 滤波后Y = fft(Bf, n);Ayy = (abs(Y));Ayy = Ayy / (n / 2);Ayy(1) = Ayy(1) / 2;F=(1:n - 1)*Fs/n;plot(F(1:n/2),Ayy(1:n/2));legend('滤波前','滤波后');title('电机转动时加计数据频谱'); % ············电机震动分析············ C - IIR 一种比较简单的实现函数，滤波器的参数只能有Matlab生成了，但是其实滤波器的参数也是可以根据频率直接用C语言生成参数的，APM飞控里的 LowPassFilter2p.cpp 有实现的方法，可以移植一下。 12345678910111213141516171819202122232425262728293031323334353637#define IIR_ORDER 2 // orderdouble InPut_IIR[IIR_ORDER + 1] = &#123;0&#125;;double OutPut_IIR[IIR_ORDER + 1] = &#123;0&#125;;// Fs:400Hz Fp:10Hzdouble b_IIR[IIR_ORDER + 1] = &#123;0.000027f, 0.000054f, 0.000027f&#125;; //bdouble a_IIR[IIR_ORDER + 1] = &#123;1.000000f, -1.985190f, 0.985299f&#125;; //adouble IIR_I_Filter(double InData)&#123; double z1, z2; short i; double OutData; short na = IIR_ORDER + 1; short nb = IIR_ORDER + 1; for (i = nb - 1; i &gt; 0; i--) &#123; InPut_IIR[i] = InPut_IIR[i - 1]; &#125; InPut_IIR[0] = InData; for (z1 = 0, i = 0; i &lt; nb; i++) &#123; z1 += InPut_IIR[i] * b_IIR[i]; &#125; for (i = na - 1; i &gt; 0; i--) &#123; OutPut_IIR[i] = OutPut_IIR[i - 1]; &#125; for (z2 = 0, i = 1; i &lt; na; i++) &#123; z2 += OutPut_IIR[i] * a_IIR[i]; &#125; OutPut_IIR[0] = z1 - z2; OutData = OutPut_IIR[0]; return OutData;&#125;]]></content>
      <categories>
        <category>quadcopter</category>
      </categories>
      <tags>
        <tag>quadcopter</tag>
        <tag>height control</tag>
        <tag>height</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于工作]]></title>
    <url>%2F2017%2F10%2F22%2F%E5%85%B3%E4%BA%8E%E5%B7%A5%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[KF融合气压计和加计 移植了px4的Matrix库，并添加了矩阵求逆运算，但是由于矩阵运算迭代太多次导致其运算效率并不是很高。 malab生成IIR滤波器参数，对原始气压计进行了初步滤波。 互补融合激光测距和加计采用互补滤波融合激光测距和加计，融合之后的数据做了定高，PID控制可以稳定在+-1cm，效果不错，但是融合之后的数据略有波动。有待换成KF测试。 激光测距的数据进行了倾斜角补偿 油门摇杆控速度 高度环串级PID]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[硬件]]></title>
    <url>%2F2017%2F10%2F22%2F%E7%A1%AC%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最近一周一直在做高度控制的算法，每天加班都很晚，晚上也很少有时间做些东西，不过还是趁着这个周末的时间完成了大部分的硬件设计。 硬件的设计很多还是参考了px4的硬件，也很想尝试下能不能兼容px4固件。 todo: 后面有时间在详细整理硬件电路的设计。]]></content>
      <categories>
        <category>quadcopter</category>
      </categories>
      <tags>
        <tag>quadcopter</tag>
        <tag>hardware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些想法]]></title>
    <url>%2F2017%2F10%2F13%2F%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[记录一点想法 一些想法室内定点定高，室内避障，这些最基础的功能。其实我觉得这更像是一个高集成度的飞控开发平台，集成了高性能飞控平台，测距传感器，光流传感器，避障传感器，通信模组，单双目视觉。这对于开发者来说，单纯的硬件就已经非常有吸引力了。 飞控算法的话，我肯定是期望朝着商品飞控的目标去做，把飞控的用户体验和飞机的灵活性做好。 我很喜欢bitcrze团队，能够一起写作专心做喜欢的事，做一些很酷的东西出来，很希望以后有机会能够朝着他们的方向去做。 室内定位方式 双目或者目：做视觉里程计或者SLAM UWB位置融合光流传感器，我个人很想尝试这种方式，一直觉得这样应该也可以做出不错的效果 mocap 一些问题 传感器减震方式，要不要独立imu模块，单独做减震 气压计的处理 算法 软件架构 操作系统 底层驱动 姿态解算 ekf, ukf, mohony互补.. 姿态控制 pid, back-step 高度解算 kf, ukf, 互补, px4算法 高度控制 pid 油门控制方式 手动起飞算法 手动降落算法 自动起飞 自动降落 气压计和测距的切换 地形跟随模式 落地检测 位置解算 ekf, ukf 位置控制 pid 自适应 最优路径生成 路径跟随算法 避障算法 空翻 交互 视觉交互 ​ 硬件和一些结构后面再针对硬件电路分析单独写一个文章吧 机架 电机 电调 四合一电调，只有几克重 电池 遥控器接收机 飞控 体积35mm*35mm 尽量兼容px4 高级控制板（可选） 用来做飞控算法或者视觉处理 双目（可选） TOF测距 可以选用北醒的TOF测距，可以到12米远，具体需测试 Hypersen我们公司用的这家的传感器，也是TOF的，但是距离可以到30米 光流 可以采用bitcraze的开源的 淘宝有一款五十多块钱的，很便宜，过段时间买回来测试下 TOF测距避障 VL53L0X,体积超小，飞行器四面各一个，用来避障。 LED 用来灯光交互 GPS Ublox M8N 通信 2.4G数传或者wifi模组 2017.10.26 最近想了想，觉得室内飞行还是小飞机比较好些，既方便调试又方便飞行，特别是现在住的地方也不大，所以一直都在挑小飞机的硬件。 130轴距是个不错的选择，采用1106电机，6000KV，3寸碳桨，15A四合一电调，飞控自己做成30mm*30mm，再加上激光测距和光流。 1106电机 6.6g一个，四个26.4g，3020桨的时候单个电机能到300g以上最大推力，很暴力 激光测距只有5~6g中，体积也很小 光流体积20mm*20mm，也可以自己做，等飞控做稳定了还是想自己做光流和TOF模块 电池可以用2S或者3S的520mah，14500电池看起来也可以，就是不知道重量合适不合适 等发了工资要找机会整一套，还有好多工具需要啊，风枪、焊台、调试夹、放大镜、电子秤。。。还需要一套螺丝刀，之前的这些装备毕业的时候全都送人了 还有好多论文需要一个个去研究： 关于姿态解算的论文，px4的论文，bitcraze的论文，还有ETH的一些论文，路径生成和控制的论文。。。慢慢啃吧]]></content>
      <categories>
        <category>quadcopter</category>
      </categories>
      <tags>
        <tag>quadcopter</tag>
        <tag>ideas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高度控制]]></title>
    <url>%2F2017%2F10%2F12%2F%E9%AB%98%E5%BA%A6%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[思路关于高度控制有两种不同的控制方式： 遥控器油门代表期望速度，回中代表期望速度为0，油门向上期望速度为正，油门向下期望速度为负。油门推进时，高度环只有速度环，位置环不起作用。油门回中，期望速度为0，此时飞行器悬停，位置环和速度环嵌套。 notice:油门回中时，期望速度即为0，但是实际速度并不会立即为0，由于速度环的作用，实际速度会逐渐减为0.如果在油门回中时也就是期望速度为0时，立即锁定当前高度，则飞行器会先上升一段高度，等到实际速度减为0，再下降悬停到锁定的高度，也就是油门回中时的高度。这种方式用户体验并不是很好，会给人一种很不稳的感觉。所以更好的应该是油门回中之后，飞行器应该悬停在实际飞行速度减为0的时候的高度而不是油门回中时的高度。 遥控器油门还是代表期望速度，但是把期望速度积分得出期望位置。油门不回中时，期望速度不为0，积分后期望位置在不停更新，油门推进时由位置环和速度环嵌套。油门回中时，期望速度为0，积分后的期望位置不发生改变，飞行器即悬停。 其实两种方式不同的地方就是第一种推油门的时候是控的目标速度，只有速度环，第二种推油门的时候就是控的目标位置，位置环和速度环嵌套。 想要获得比较好的效果，问题还是有很多的： 高度的PID控制器一般都有三环，位置环-&gt;速度环-&gt;加速度环，PID想要比较好的效果需要有几点注意的地方，比如系统的延时，数据的更新频率，以及数据的精度。 激光测距的更新频率比较慢，一般就20Hz~100Hz之间，要想比较好的效果的话这种控制频率就有点慢了，所以激光的数据还是要和加计的数据进行融合，融合了加计之后可以提高一些响应速度，但是肯定也会引入一定的噪声。所以在融合的时候要在响应速度和数据的波动上做一些处理，达到最好效果。 框架 todo:待补充 实现 todo:待完善 控制目标速度123456789101112131415161718192021222324252627float _dst_vel_z; // destination velocityfloat _est_vel_z; // estimate velocityfloat _dst_pos_z; // destination positionfloat _est_pos_z; // estimate positionbool _dst_pos_z_locked; // calc desired pos_z by velocity_zif ( fabsf( _dst_vel_z ) &lt; 5 ) &#123; // usr wanna stop if ( fabsf( _est_vel_z ) &lt; 15 ) &#123; // craft is slow enough if ( !_dst_pos_z_locked ) &#123; // pos_z not fixed _dst_pos_z = _est_pos_z; _dst_pos_z_locked = true; &#125; &#125;else&#123; // craft is fast。这里有一个风险：永远控不到较小的速度，位移环就一直不起作用 if ( !_dst_pos_z_locked ) &#123; // craft is fast, but not fixed now, ctrl speed until slow enough _dst_pos_z = _est_pos_z; &#125; //else&#123; // else craft is speed up by extern force( wind, sudden turn-around. etc... ) // desired position should still hold( but maybe changed when difference is too large ) //&#125; &#125;&#125;else&#123; // users wanna move _dst_pos_z = _est_pos_z; _dst_pos_z_locked = false;&#125;]]></content>
      <categories>
        <category>quadcopter</category>
      </categories>
      <tags>
        <tag>quadcopter</tag>
        <tag>height control</tag>
        <tag>height</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位置控制-px4]]></title>
    <url>%2F2017%2F10%2F12%2F%E4%BD%8D%E7%BD%AE%E6%8E%A7%E5%88%B6-px4%2F</url>
    <content type="text"><![CDATA[主要分析px4的位置控制方式，源码位于mc_pos_control.cpp文件 未完待续！ 思路 todo 框架 todo 实现 todo]]></content>
      <categories>
        <category>quadcopter</category>
      </categories>
      <tags>
        <tag>quadcopter</tag>
        <tag>position control</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BeagleBone Blue 编译部署]]></title>
    <url>%2F2017%2F10%2F09%2FBeaglebone%20%E7%BC%96%E8%AF%91%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[一直想找一款能够快速开发的，高性能的板子，挑来挑去只有beaglebone blue最为合适，虽然价格略贵。 Beaglebone blue 搭载Debian系统，之前完全没玩过嵌入式linux，所以上手还是需要一点时间，今天查了下资料大概了解了开发步骤。主要有以下几种方式： PC上使用VS Code或者Sublime 进行代码编辑，之后使用WinSCP部署到Beaglebone上，在Beaglebone上使用makefile进行编译。也是比较高效的一种方法吧。 Visual Studio 2017 可以进行linux嵌入式开发了，可以直接在PC上编译生成可执行文件，然后直接在线debug，非常方便。但是我用Visual Studio的时候，一些linux头文件找不到，还有一些beaglebone的API头文件缺失，一直没有编译成功，可能是我方法有问题，这个后面有时间在解决。不过Hello World还是可以运行成功的。 还有很多开发者是在linux上使用esplice或者Qt Creator再加上交叉编译工具进行开发的，也是可以直接运行部署到beaglebone上的，不过这种方法我并没有进行尝试。 还是先记录下第一种方法怎么操作的吧： 下载安装WinSCP2.填入Beaglebone的主机名，端口号，还有用户名和密码，点击登录即可。登录之后的界面：左边是PC的文件目录，右边是Beaglebone的文件目录，如果要复制文件直接拖过去就行了，挺方便的。 3.在/home/debian文件夹中新建BeaglePilot文件夹，存放我们的工程项目。把我们在PC上写好的.c和Makefile直接拖过来。 4.在Putty或者WinSCP直接打开一个终端进入BeaglePilot目录，ls会看到我们刚拖进来的两个文件，然后make BeaglePilot编译生成可执行文件，这时候再ls就会看到生成的.o文件了，sudo ./BeaglePilot命令之后输入密码就可以执行我们的代码了。 这样就可以直接在PC上用自己熟悉的编辑器写完代码，部署到Beaglebone上面，直接Make，然后执行，非常方便。 后面有时间还是研究下后面两种调试方式吧，看下哪种更高效一些，接下来就可以快速验证自己的算法了。]]></content>
      <categories>
        <category>beaglebone</category>
      </categories>
      <tags>
        <tag>beaglebone</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高度融合]]></title>
    <url>%2F2017%2F09%2F24%2F%E9%AB%98%E5%BA%A6%E8%9E%8D%E5%90%88%2F</url>
    <content type="text"><![CDATA[传感器数据数据融合所需要的传感器数据： 1.气压计：在没有超声波，激光测距等传感器的时候，算是比较可靠的一个传感器了，但是其效果也就是仅仅能用，想要比较好的效果的话还是要超声波或激光的。气压计目前比较好的精度也就是10cm，的确上下移动10cm也会有效果，但是其噪声实在太大，噪声波动一般都在50cm+，所以一般都会融合加计，融合的算法有很多种，融合之后的效果在短时间内还可以接受，可以控制在5-10cm左右，但是长时间，比如静止放置十分钟或者更久，就会产生比较大的漂移，一般都会漂出去半米远，所以只用气压计融合加计并不能做出一个特别好的定高效果。 2.加计，加计的数据要是姿态解算之后的数据，也就是大地坐标系下z轴加速度计数据，要减去重力加速度。姿态解算之后的加计噪声应该会比较小了。 3.超声波，这个我没怎么用过，但是一直感觉这玩意效果也不是很好，距离又近，一般就只有3-5米远吧，个别也有更远一些的，但是价格就贵了，发射角又大，而且非常容易受到振动和气流的影响。 4.激光传感器，激光传感器本身的价格是非常贵的，但是最近TOF测距的技术发展很快，国内已经有TOF测距可以到12米甚至更远的距离，价格也不算贵，精度是非常高，cm级的精度了，更新频率几十Hz到几百Hz的都有。 算法 1.互补滤波，应该是比较简单的一种算法。把气压计得出的高度数据微分得出速度，加计积分也得出速度，之后相互融合。 2.ekf，也就是扩展卡尔曼了，不过由于高度的状态方程是线性的，所以kf和ekf也就差别不大，ekf的算法关键的就是状态转移方程的建立了，不同的状态方程最后得出的效果也会略有区别，当然调参的小技巧可能也会不大一样，不过重点都是Q,R的参数调试。 3.还有一种处理方式就是px4中最开始使用的一种算法，其实也是预测-校验的一种思路，只不过比ekf要简单一些。 KF融合公式卡尔曼算法最重要的就是状态方程和转移方程的建立了，会直接影响到最终数据融合的效果。整个算法过程分为两个部分，预测和矫正： Predict: Predicted (a priori) state estimate: \hat{x}_{k|k-1} = F_kx_{k-1|k-1} + B_ku_k Predicted (a priori) estimate covariance: P_{k|k-1} = F_kP_{k-1|k-1}F^T_{k} + Q_kUpdate: Innovation or measurement pre-fit residual: \widetilde{y}_k = z_k - H_k\hat{x}_{k|k-1} Innovation (or pre-fit residual) covariance: S_k = R_k + H_kP_{k|k-1}H^T_k Optimal Kalman gain: K_k = P_{k|k-1}H^T_kS^{-1}_k Updated (a posteriori) state estimate: \hat{x}_{k|k} = \hat{x}_{k|k-1}+ K_k\widetilde{y}_k Updated (a posteriori) estimate covariance: P_{k|k-1} = (I - K_kH_k)P_{k|k-1} Measurement post-fit residual: \widetilde{y}_{k|k} = z_k - H_k\hat{x}_{k|k}状态方程 x = \left[ \begin{array}{ccc} h \\\ v \\\ a \end{array} \right] \\\ \\\ F = \left[ \begin{array}{ccc} 1 & t & 0 \\\ 0 & 1 & t \\\ 0 & 0 & 1 \end{array} \right] \\\ \\\ Z = \left[ \begin{array}{ccc} h_{baro} \\\ acc_{ned} \end{array} \right]\\\ \\\ H = \left[ \begin{array}{ccc} 1 & 0 & 0 \\\ 0 & 0 & 1 \end{array} \right]即 \left[ \begin{array}{ccc} h+vt \\\ v+at \\\ a \end{array} \right] = \left[ \begin{array}{ccc} 1 & t & 0 \\\ 0 & 1 & t \\\ 0 & 0 & 1 \end{array} \right]\left[ \begin{array}{ccc} h \\\ v \\\ a \end{array} \right]\\\ \\\ \left[ \begin{array}{ccc} h_{err} \\\ acc_{err} \end{array} \right]= \left[ \begin{array}{ccc} h_{baro} \\\ acc_{ned} \end{array} \right] - \left[ \begin{array}{ccc} 1 & 0 & 0 \\\ 0 & 0 & 1 \end{array} \right] \left[ \begin{array}{ccc} h \\\ v \\\ a \end{array} \right]设置参数 P = \left[ \begin{array}{ccc} 0 & t & 60 \\\ 1 & 1 & 3 \\\ 2 & 2 & 0.1 \end{array} \right] \\\ \\\ Q = \left[ \begin{array}{ccc} 0.0000001 & 0 & 0 \\\ 0 & 0.000005 & 0 \\\ 0 & 0 & 0.05 \end{array} \right] \\\ \\\ R = \left[ \begin{array}{ccc} 0 & 0 & 15000 \\\ 0 & 0 & 200 \end{array} \right] \\\ \\\ I = \left[ \begin{array}{ccc} 0 & 0 & 0 \\\ 0 & 1 & 0 \\\ 0 & 0 & 1 \end{array} \right] \\\关于R和Q矩阵参数的设置需要一起调试，Q越小越相信预测值，R越小越相信测量值，两个值相互影响，最优参数不唯一的，根据实际情况调试，调试时可以先观测输出的加速度曲线，因为速度一部分是由加速度积分得到的，如果加速度都有问题的话速度的效果肯定也不会好，同理接着调试速度的参数，最后调试高度的参数。 测量值其实就是输入的气压计高度，预测值的话则是加计积分和气压计高度融合得来的。 过于相信预测值的话，也就是Q过小或者R过大，会造成收敛速度过慢，同时由于预测值是由加速度积分来的，所以飞机的震动会对加速度造成影响，也会对融合的输出值造成比较大影响，其次，如果在刚上电时加速度计有偏移，则会对融合的输出值产生很大影响，如果这个时候Q过小或者R过大，很有可能造成收敛时间特别长，虽然最后也能够收敛。 如果过于相信测量值的话，由于气压计的噪声非常大，肯定会对输出值的平坦度造成一些影响，短时间内的数据可能不够平滑。 codekf参数123456789101112131415161718192021222324252627alt_est_kf.set_H(0, 0, 1);alt_est_kf.set_H(1, 2, 1);alt_est_kf.set_P(0, 0, 60);alt_est_kf.set_P(1, 1, 3);alt_est_kf.set_P(2, 2, 0.1f);alt_est_kf.set_Q(0, 0, 0.0000001f);alt_est_kf.set_Q(1, 1, 0.000005f);alt_est_kf.set_Q(2, 2, 0.05f);alt_est_kf.set_R(0, 0, 15000);alt_est_kf.set_R(1, 1, 200);alt_est_kf.set_F(0, 0, 1);alt_est_kf.set_F(0, 1, Ts_q);alt_est_kf.set_F(1, 1, 1);alt_est_kf.set_F(1, 2, Ts_q);alt_est_kf.set_F(2, 2, 1);alt_est_kf.set_I(0, 0, 1);alt_est_kf.set_I(1, 1, 1);alt_est_kf.set_I(2, 2, 1);alt_est_kf.set_X(0, 0, 0);alt_est_kf.set_X(1, 0, 0);alt_est_kf.set_X(2, 0, 0); kf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#ifndef __ekf_h#define __ekf_h#include "ss_matrix_q.h"using namespace matrix;/* * M is the number of status, N is the number of observe */template &lt;int M, int N&gt;class ekf&#123; protected: Matrix&lt;float, M, M&gt; P; Matrix&lt;float, M, M&gt; Q; Matrix&lt;float, N, N&gt; R; Matrix&lt;float, M, M&gt; I; Matrix&lt;float, M, M&gt; F; Matrix&lt;float, N, M&gt; H; Matrix&lt;float, M, 1&gt; X; Matrix&lt;float, N, 1&gt; Z; private: Matrix&lt;float, N, N&gt; S; Matrix&lt;float, M, N&gt; K; public: void set_P(int m, int n, float value) &#123; P(m, n) = value; &#125; void set_Q(int m, int n, float value) &#123; Q(m, n) = value; &#125; void set_R(int m, int n, float value) &#123; R(m, n) = value; &#125; void set_I(int m, int n, float value) &#123; I(m, n) = value; &#125; void set_F(int m, int n, float value) &#123; F(m, n) = value; &#125; void set_H(int m, int n, float value) &#123; H(m, n) = value; &#125; void set_X(int m, int n, float value) &#123; X(m, n) = value; &#125; void set_Z(int m, int n, float value) &#123; Z(m, n) = value; &#125; float get_X(int m, int n) &#123; return X(m, n); &#125; void predict(); void correct();&#125;;template &lt;int M, int N&gt;void ekf&lt;M, N&gt;::predict()&#123; X = F * X; P = F * P * F.transpose() + Q;&#125;template &lt;int M, int N&gt;void ekf&lt;M, N&gt;::correct()&#123; S = H * P * H.transpose() + R; K = P * H.transpose() * S.inverse(); X = X + K * (Z - H * X); P = (I - K * H) * P;&#125;#endif 互补融合 TODO px4高度估算 TODO 调试 todo:待补充]]></content>
      <categories>
        <category>quadcopter</category>
      </categories>
      <tags>
        <tag>quadcopter</tag>
        <tag>height</tag>
        <tag>height fusion</tag>
      </tags>
  </entry>
</search>
