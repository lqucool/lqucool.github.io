<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一些想法]]></title>
    <url>%2F2017%2F10%2F13%2F%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[这里记录一些关于一些思路和想法，也算是一些总结。 一些想法室内定点定高，室内避障，这些最基础的功能。其实我觉得这更像是一个高集成度的飞控开发平台，集成了高性能飞控平台，测距传感器，光流传感器，避障传感器，通信模组，单双目视觉。这对于开发者来说，单纯的硬件就已经非常有吸引力了。 飞控算法的话，我肯定是期望朝着商品飞控的目标去做，把飞控的用户体验和飞机的灵活性做好。 我很喜欢bitcrze团队，能够一起写作专心做喜欢的事，做一些很酷的东西出来，很希望以后有机会能够朝着他们的方向去做。 室内定位方式1. 双目或者目：做视觉里程计或者SLAM 2. UWB位置融合光流传感器，我个人很想尝试这种方式，一直觉得这样应该也可以做出不错的效果 3. mocap 一些问题 传感器减震方式，要不要独立imu模块，单独做减震 气压计的处理 算法 软件架构 操作系统 底层驱动 姿态解算 ekf, ukf, mohony互补.. 姿态控制 pid, back-step 高度解算 kf, ukf, 互补, px4算法 高度控制 pid 油门控制方式 手动起飞算法 手动降落算法 自动起飞 自动降落 气压计和测距的切换 地形跟随模式 落地检测 位置解算 ekf, ukf 位置控制 pid 自适应 最优路径生成 路径跟随算法 避障算法 空翻 交互 视觉交互 ​ 硬件和一些结构后面再针对硬件电路分析单独写一个文章吧 机架 电机 电调 四合一电调，只有几克重 电池 遥控器接收机 飞控 体积35mm*35mm 尽量兼容px4 高级控制板（可选） 用来做飞控算法或者视觉处理 双目（可选） TOF测距 可以选用北醒的TOF测距，可以到12米远，具体需测试 Hypersen我们公司用的这家的传感器，也是TOF的，但是距离可以到30米 光流 可以采用bitcraze的开源的 淘宝有一款五十多块钱的，很便宜，过段时间买回来测试下 TOF测距避障 VL53L0X,体积超小，飞行器四面各一个，用来避障。 LED 用来灯光交互 GPS Ublox M8N 通信 2.4G数传或者wifi模组]]></content>
      <categories>
        <category>quadcopter</category>
      </categories>
      <tags>
        <tag>quadcopter</tag>
        <tag>ideas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高度控制]]></title>
    <url>%2F2017%2F10%2F12%2F%E9%AB%98%E5%BA%A6%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[思路关于高度控制有两种不同的控制方式： 遥控器油门代表期望速度，回中代表期望速度为0，油门向上期望速度为正，油门向下期望速度为负。油门推进时，高度环只有速度环，位置环不起作用。油门回中，期望速度为0，此时飞行器悬停，位置环和速度环嵌套。 notice:油门回中时，期望速度即为0，但是实际速度并不会立即为0，由于速度环的作用，实际速度会逐渐减为0.如果在油门回中时也就是期望速度为0时，立即锁定当前高度，则飞行器会先上升一段高度，等到实际速度减为0，再下降悬停到锁定的高度，也就是油门回中时的高度。这种方式用户体验并不是很好，会给人一种很不稳的感觉。所以更好的应该是油门回中之后，飞行器应该悬停在实际飞行速度减为0的时候的高度而不是油门回中时的高度。 遥控器油门还是代表期望速度，但是把期望速度积分得出期望位置。油门不回中时，期望速度不为0，积分后期望位置在不停更新，油门推进时由位置环和速度环嵌套。油门回中时，期望速度为0，积分后的期望位置不发生改变，飞行器即悬停。 其实两种方式不同的地方就是第一种推油门的时候是控的目标速度，只有速度环，第二种推油门的时候就是控的目标位置，位置环和速度环嵌套。 框架 todo:待补充 实现 todo:待完善 控制目标速度123456789101112131415161718192021222324252627float _dst_vel_z; // destination velocityfloat _est_vel_z; // estimate velocityfloat _dst_pos_z; // destination positionfloat _est_pos_z; // estimate positionbool _dst_pos_z_locked; // calc desired pos_z by velocity_zif ( fabsf( _dst_vel_z ) &lt; 5 ) &#123; // usr wanna stop if ( fabsf( _est_vel_z ) &lt; 15 ) &#123; // craft is slow enough if ( !_dst_pos_z_locked ) &#123; // pos_z not fixed _dst_pos_z = _est_pos_z; _dst_pos_z_locked = true; &#125; &#125;else&#123; // craft is fast。这里有一个风险：永远控不到较小的速度，位移环就一直不起作用 if ( !_dst_pos_z_locked ) &#123; // craft is fast, but not fixed now, ctrl speed until slow enough _dst_pos_z = _est_pos_z; &#125; //else&#123; // else craft is speed up by extern force( wind, sudden turn-around. etc... ) // desired position should still hold( but maybe changed when difference is too large ) //&#125; &#125;&#125;else&#123; // users wanna move _dst_pos_z = _est_pos_z; _dst_pos_z_locked = false;&#125;]]></content>
      <categories>
        <category>quadcopter</category>
      </categories>
      <tags>
        <tag>quadcopter</tag>
        <tag>height control</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位置控制-px4]]></title>
    <url>%2F2017%2F10%2F12%2F%E4%BD%8D%E7%BD%AE%E6%8E%A7%E5%88%B6-px4%2F</url>
    <content type="text"><![CDATA[主要分析px4的位置控制方式，源码位于mc_pos_control.cpp文件 未完待续！ 思路 todo 框架 todo 实现 todo]]></content>
      <categories>
        <category>quadcopter</category>
      </categories>
      <tags>
        <tag>quadcopter</tag>
        <tag>position control</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BeagleBone Blue 编译部署]]></title>
    <url>%2F2017%2F10%2F09%2FBeaglebone%20%E7%BC%96%E8%AF%91%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[一直想找一款能够快速开发的，高性能的板子，挑来挑去只有beaglebone blue最为合适，虽然价格略贵。 Beaglebone blue 搭载Debian系统，之前完全没玩过嵌入式linux，所以上手还是需要一点时间，今天查了下资料大概了解了开发步骤。主要有以下几种方式： PC上使用VS Code或者Sublime 进行代码编辑，之后使用WinSCP部署到Beaglebone上，在Beaglebone上使用makefile进行编译。也是比较高效的一种方法吧。 Visual Studio 2017 可以进行linux嵌入式开发了，可以直接在PC上编译生成可执行文件，然后直接在线debug，非常方便。但是我用Visual Studio的时候，一些linux头文件找不到，还有一些beaglebone的API头文件缺失，一直没有编译成功，可能是我方法有问题，这个后面有时间在解决。不过Hello World还是可以运行成功的。 还有很多开发者是在linux上使用esplice或者Qt Creator再加上交叉编译工具进行开发的，也是可以直接运行部署到beaglebone上的，不过这种方法我并没有进行尝试。 还是先记录下第一种方法怎么操作的吧： 下载安装WinSCP2.填入Beaglebone的主机名，端口号，还有用户名和密码，点击登录即可。登录之后的界面：左边是PC的文件目录，右边是Beaglebone的文件目录，如果要复制文件直接拖过去就行了，挺方便的。 3.在/home/debian文件夹中新建BeaglePilot文件夹，存放我们的工程项目。把我们在PC上写好的.c和Makefile直接拖过来。 4.在Putty或者WinSCP直接打开一个终端进入BeaglePilot目录，ls会看到我们刚拖进来的两个文件，然后make BeaglePilot编译生成可执行文件，这时候再ls就会看到生成的.o文件了，sudo ./BeaglePilot命令之后输入密码就可以执行我们的代码了。 这样就可以直接在PC上用自己熟悉的编辑器写完代码，部署到Beaglebone上面，直接Make，然后执行，非常方便。 后面有时间还是研究下后面两种调试方式吧，看下哪种更高效一些，接下来就可以快速验证自己的算法了。]]></content>
      <categories>
        <category>beaglebone</category>
      </categories>
      <tags>
        <tag>beaglebone</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高度融合]]></title>
    <url>%2F2017%2F09%2F24%2F%E9%AB%98%E5%BA%A6%E8%9E%8D%E5%90%88%2F</url>
    <content type="text"><![CDATA[传感器数据数据融合所需要的传感器数据： 1.气压计：在没有超声波，激光测距等传感器的时候，算是比较可靠的一个传感器了，但是其效果也就是仅仅能用，想要比较好的效果的话还是要超声波或激光的。气压计目前比较好的精度也就是10cm，的确上下移动10cm也会有效果，但是其噪声实在太大，噪声波动一般都在50cm+，所以一般都会融合加计，融合的算法有很多种，融合之后的效果在短时间内还可以接受，可以控制在5-10cm左右，但是长时间，比如静止放置十分钟或者更久，就会产生比较大的漂移，一般都会漂出去半米远，所以只用气压计融合加计并不能做出一个特别好的定高效果。 2.加计，加计的数据要是姿态解算之后的数据，也就是大地坐标系下z轴加速度计数据，要减去重力加速度。姿态解算之后的加计噪声应该会比较小了。 3.超声波，这个我没怎么用过，但是一直感觉这玩意效果也不是很好，距离又近，一般就只有3-5米远吧，个别也有更远一些的，但是价格就贵了，发射角又大，而且非常容易受到振动和气流的影响。 4.激光传感器，激光传感器本身的价格是非常贵的，但是最近TOF测距的技术发展很快，国内已经有TOF测距可以到12米甚至更远的距离，价格也不算贵，精度是非常高，cm级的精度了，更新频率几十Hz到几百Hz的都有。 算法 1.互补滤波，应该是比较简单的一种算法。把气压计得出的高度数据微分得出速度，加计积分也得出速度，之后相互融合。 2.ekf，也就是扩展卡尔曼了，不过由于高度的状态方程是线性的，所以kf和ekf也就差别不大，ekf的算法关键的就是状态转移方程的建立了，不同的状态方程最后得出的效果也会略有区别，当然调参的小技巧可能也会不大一样，不过重点都是Q,R的参数调试。 3.还有一种处理方式就是px4中最开始使用的一种算法，其实也是预测-校验的一种思路，只不过比ekf要简单一些。 KF融合公式卡尔曼算法最重要的就是状态方程和转移方程的建立了，会直接影响到最终数据融合的效果。整个算法过程分为两个部分，预测和矫正： Predict: Predicted (a priori) state estimate: \hat{x}_{k|k-1} = F_kx_{k-1|k-1} + B_ku_k Predicted (a priori) estimate covariance: P_{k|k-1} = F_kP_{k-1|k-1}F^T_{k} + Q_kUpdate: Innovation or measurement pre-fit residual: \widetilde{y}_k = z_k - H_k\hat{x}_{k|k-1} Innovation (or pre-fit residual) covariance: S_k = R_k + H_kP_{k|k-1}H^T_k Optimal Kalman gain: K_k = P_{k|k-1}H^T_kS^{-1}_k Updated (a posteriori) state estimate: \hat{x}_{k|k} = \hat{x}_{k|k-1}+ K_k\widetilde{y}_k Updated (a posteriori) estimate covariance: P_{k|k-1} = (I - K_kH_k)P_{k|k-1} Measurement post-fit residual: \widetilde{y}_{k|k} = z_k - H_k\hat{x}_{k|k}状态方程 x = \left[ \begin{array}{ccc} h \\\ v \\\ a \end{array} \right] \\\ \\\ F = \left[ \begin{array}{ccc} 1 & t & 0 \\\ 0 & 1 & t \\\ 0 & 0 & 1 \end{array} \right] \\\ \\\ Z = \left[ \begin{array}{ccc} h_{baro} \\\ acc_{ned} \end{array} \right]\\\ \\\ H = \left[ \begin{array}{ccc} 1 & 0 & 0 \\\ 0 & 0 & 1 \end{array} \right]即 \left[ \begin{array}{ccc} h+vt \\\ v+at \\\ a \end{array} \right] = \left[ \begin{array}{ccc} 1 & t & 0 \\\ 0 & 1 & t \\\ 0 & 0 & 1 \end{array} \right]\left[ \begin{array}{ccc} h \\\ v \\\ a \end{array} \right]\\\ \\\ \left[ \begin{array}{ccc} h_{err} \\\ acc_{err} \end{array} \right]= \left[ \begin{array}{ccc} h_{baro} \\\ acc_{ned} \end{array} \right] - \left[ \begin{array}{ccc} 1 & 0 & 0 \\\ 0 & 0 & 1 \end{array} \right] \left[ \begin{array}{ccc} h \\\ v \\\ a \end{array} \right]设置参数 P = \left[ \begin{array}{ccc} 0 & t & 60 \\\ 1 & 1 & 3 \\\ 2 & 2 & 0.1 \end{array} \right] \\\ \\\ Q = \left[ \begin{array}{ccc} 0.0000001 & 0 & 0 \\\ 0 & 0.000005 & 0 \\\ 0 & 0 & 0.05 \end{array} \right] \\\ \\\ R = \left[ \begin{array}{ccc} 0 & 0 & 15000 \\\ 0 & 0 & 200 \end{array} \right] \\\ \\\ I = \left[ \begin{array}{ccc} 0 & 0 & 0 \\\ 0 & 1 & 0 \\\ 0 & 0 & 1 \end{array} \right] \\\关于R和Q矩阵参数的设置需要一起调试，Q越小越相信预测值，R越小越相信测量值，两个值相互影响，最优参数不唯一的，根据实际情况调试，调试时可以先观测输出的加速度曲线，因为速度一部分是由加速度积分得到的，如果加速度都有问题的话速度的效果肯定也不会好，同理接着调试速度的参数，最后调试高度的参数。 测量值其实就是输入的气压计高度，预测值的话则是加计积分和气压计高度融合得来的。 过于相信预测值的话，也就是Q过小或者R过大，会造成收敛速度过慢，同时由于预测值是由加速度积分来的，所以飞机的震动会对加速度造成影响，也会对融合的输出值造成比较大影响，其次，如果在刚上电时加速度计有偏移，则会对融合的输出值产生很大影响，如果这个时候Q过小或者R过大，很有可能造成收敛时间特别长，虽然最后也能够收敛。 如果过于相信测量值的话，由于气压计的噪声非常大，肯定会对输出值的平坦度造成一些影响，短时间内的数据可能不够平滑。 codekf参数123456789101112131415161718192021222324252627alt_est_kf.set_H(0, 0, 1);alt_est_kf.set_H(1, 2, 1);alt_est_kf.set_P(0, 0, 60);alt_est_kf.set_P(1, 1, 3);alt_est_kf.set_P(2, 2, 0.1f);alt_est_kf.set_Q(0, 0, 0.0000001f);alt_est_kf.set_Q(1, 1, 0.000005f);alt_est_kf.set_Q(2, 2, 0.05f);alt_est_kf.set_R(0, 0, 15000);alt_est_kf.set_R(1, 1, 200);alt_est_kf.set_F(0, 0, 1);alt_est_kf.set_F(0, 1, Ts_q);alt_est_kf.set_F(1, 1, 1);alt_est_kf.set_F(1, 2, Ts_q);alt_est_kf.set_F(2, 2, 1);alt_est_kf.set_I(0, 0, 1);alt_est_kf.set_I(1, 1, 1);alt_est_kf.set_I(2, 2, 1);alt_est_kf.set_X(0, 0, 0);alt_est_kf.set_X(1, 0, 0);alt_est_kf.set_X(2, 0, 0); kf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#ifndef __ekf_h#define __ekf_h#include "ss_matrix_q.h"using namespace matrix;/* * M is the number of status, N is the number of observe */template &lt;int M, int N&gt;class ekf&#123; protected: Matrix&lt;float, M, M&gt; P; Matrix&lt;float, M, M&gt; Q; Matrix&lt;float, N, N&gt; R; Matrix&lt;float, M, M&gt; I; Matrix&lt;float, M, M&gt; F; Matrix&lt;float, N, M&gt; H; Matrix&lt;float, M, 1&gt; X; Matrix&lt;float, N, 1&gt; Z; private: Matrix&lt;float, N, N&gt; S; Matrix&lt;float, M, N&gt; K; public: void set_P(int m, int n, float value) &#123; P(m, n) = value; &#125; void set_Q(int m, int n, float value) &#123; Q(m, n) = value; &#125; void set_R(int m, int n, float value) &#123; R(m, n) = value; &#125; void set_I(int m, int n, float value) &#123; I(m, n) = value; &#125; void set_F(int m, int n, float value) &#123; F(m, n) = value; &#125; void set_H(int m, int n, float value) &#123; H(m, n) = value; &#125; void set_X(int m, int n, float value) &#123; X(m, n) = value; &#125; void set_Z(int m, int n, float value) &#123; Z(m, n) = value; &#125; float get_X(int m, int n) &#123; return X(m, n); &#125; void predict(); void correct();&#125;;template &lt;int M, int N&gt;void ekf&lt;M, N&gt;::predict()&#123; X = F * X; P = F * P * F.transpose() + Q;&#125;template &lt;int M, int N&gt;void ekf&lt;M, N&gt;::correct()&#123; S = H * P * H.transpose() + R; K = P * H.transpose() * S.inverse(); X = X + K * (Z - H * X); P = (I - K * H) * P;&#125;#endif 互补融合 TODO px4高度估算 TODO 调试 todo:待补充]]></content>
      <categories>
        <category>quadcopter</category>
      </categories>
      <tags>
        <tag>quadcopter</tag>
        <tag>height fusion</tag>
      </tags>
  </entry>
</search>
