<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Qu&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lqucool.github.io/"/>
  <updated>2017-10-09T16:00:00.000Z</updated>
  <id>https://lqucool.github.io/</id>
  
  <author>
    <name>Qu.L</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BeagleBone Blue 编译部署</title>
    <link href="https://lqucool.github.io/2017/10/09/Beaglebone%20%E7%BC%96%E8%AF%91%E9%83%A8%E7%BD%B2/"/>
    <id>https://lqucool.github.io/2017/10/09/Beaglebone 编译部署/</id>
    <published>2017-10-08T16:00:00.000Z</published>
    <updated>2017-10-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直想找一款能够快速开发的，高性能的板子，挑来挑去只有beaglebone blue最为合适，虽然价格略贵。</p><blockquote><p>Beaglebone blue 搭载Debian系统，之前完全没玩过嵌入式linux，所以上手还是需要一点时间，今天查了下资料大概了解了开发步骤。主要有以下几种方式：</p><ol><li>PC上使用VS Code或者Sublime 进行代码编辑，之后使用WinSCP部署到Beaglebone上，在Beaglebone上使用makefile进行编译。也是比较高效的一种方法吧。</li><li>Visual Studio 2017 可以进行linux嵌入式开发了，可以直接在PC上编译生成可执行文件，然后直接在线debug，非常方便。但是我用Visual Studio的时候，一些linux头文件找不到，还有一些beaglebone的API头文件缺失，一直没有编译成功，可能是我方法有问题，这个后面有时间在解决。不过Hello World还是可以运行成功的。</li><li>还有很多开发者是在linux上使用esplice或者Qt Creator再加上交叉编译工具进行开发的，也是可以直接运行部署到beaglebone上的，不过这种方法我并没有进行尝试。</li></ol></blockquote><p>还是先记录下第一种方法怎么操作的吧：</p><ol><li>下载安装WinSCP<br><img src="http://owsesa4hj.bkt.clouddn.com/WinSCP%E7%99%BB%E5%BD%95.png" alt="avatar"><br>2.填入Beaglebone的主机名，端口号，还有用户名和密码，点击登录即可。<br>登录之后的界面：<br><img src="http://owsesa4hj.bkt.clouddn.com/WinSCP%E7%95%8C%E9%9D%A2.png" alt="avatar"><br>左边是PC的文件目录，右边是Beaglebone的文件目录，如果要复制文件直接拖过去就行了，挺方便的。</li></ol><p>3.在/home/debian文件夹中新建BeaglePilot文件夹，存放我们的工程项目。把我们在PC上写好的.c和Makefile直接拖过来。</p><p>4.在Putty或者WinSCP直接打开一个终端进入BeaglePilot目录，<code>ls</code>会看到我们刚拖进来的两个文件，然后<code>make BeaglePilot</code>编译生成可执行文件，这时候再<code>ls</code>就会看到生成的.o文件了，<code>sudo ./BeaglePilot</code>命令之后输入密码就可以执行我们的代码了。<br><img src="http://owsesa4hj.bkt.clouddn.com/putty%E6%93%8D%E4%BD%9C.png" alt="avatar"></p><p>这样就可以直接在PC上用自己熟悉的编辑器写完代码，部署到Beaglebone上面，直接Make，然后执行，非常方便。</p><p><img src="http://owsesa4hj.bkt.clouddn.com/B%E5%86%99%E4%BB%A3%E7%A0%81%E7%95%8C%E9%9D%A2.png" alt="avatar"></p><p>后面有时间还是研究下后面两种调试方式吧，看下哪种更高效一些，接下来就可以快速验证自己的算法了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直想找一款能够快速开发的，高性能的板子，挑来挑去只有beaglebone blue最为合适，虽然价格略贵。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Beaglebone blue 搭载Debian系统，之前完全没玩过嵌入式linux，所以上手还是需要一点时间，今天查了下资
      
    
    </summary>
    
      <category term="beagleBone" scheme="https://lqucool.github.io/categories/beagleBone/"/>
    
    
      <category term="beagleBone" scheme="https://lqucool.github.io/tags/beagleBone/"/>
    
  </entry>
  
  <entry>
    <title>高度融合</title>
    <link href="https://lqucool.github.io/2017/09/24/%E9%AB%98%E5%BA%A6%E8%9E%8D%E5%90%88/"/>
    <id>https://lqucool.github.io/2017/09/24/高度融合/</id>
    <published>2017-09-23T16:00:00.000Z</published>
    <updated>2017-10-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://owsesa4hj.bkt.clouddn.com/publications1.jpg" alt="avatar"></p><a id="more"></a><h3 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h3><p>数据融合所需要的传感器数据：</p><ul><li>1.气压计：在没有超声波，激光测距等传感器的时候，算是比较可靠的一个传感器了，但是其效果也就是仅仅能用，想要比较好的效果的话还是要超声波或激光的。气压计目前比较好的精度也就是10cm，的确上下移动10cm也会有效果，但是其噪声实在太大，噪声波动一般都在50cm+，所以一般都会融合加计，融合的算法有很多种，融合之后的效果在短时间内还可以接受，可以控制在5-10cm左右，但是长时间，比如静止放置十分钟或者更久，就会产生比较大的漂移，一般都会漂出去半米远，所以只用气压计融合加计并不能做出一个特别好的定高效果。</li><li>2.加计，加计的数据要是姿态解算之后的数据，也就是大地坐标系下z轴加速度计数据，要减去重力加速度。姿态解算之后的加计噪声应该会比较小了。</li><li>3.超声波，这个我没怎么用过，但是一直感觉这玩意效果也不是很好，距离又近，一般就只有3-5米远吧，个别也有更远一些的，但是价格就贵了，发射角又大，而且非常容易受到振动和气流的影响。</li><li>4.激光传感器，激光传感器本身的价格是非常贵的，但是最近TOF测距的技术发展很快，国内已经有TOF测距可以到12米甚至更远的距离，价格也不算贵，精度是非常高，cm级的精度了，更新频率几十Hz到几百Hz的都有。</li></ul><hr><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><blockquote><p>1.互补滤波，应该是比较简单的一种算法。把气压计得出的高度数据微分得出速度，加计积分也得出速度，之后相互融合。</p><p>2.ekf，也就是扩展卡尔曼了，不过由于高度的状态方程是线性的，所以kf和ekf也就差别不大，ekf的算法关键的就是状态转移方程的建立了，不同的状态方程最后得出的效果也会略有区别，当然调参的小技巧可能也会不大一样，不过重点都是Q,R的参数调试。</p><p>3.还有一种处理方式就是px4中最开始使用的一种算法，其实也是预测-校验的一种思路，只不过比ekf要简单一些。</p></blockquote><p>​<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ekf_h</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __ekf_h</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"matrix.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"inverse.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> matrix;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> M, <span class="keyword">int</span> N&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ekf</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"></div><div class="line">  <span class="keyword">protected</span>:</div><div class="line">    Matrix&lt;<span class="keyword">float</span>, M, M&gt; P;</div><div class="line">    Matrix&lt;<span class="keyword">float</span>, M, M&gt; Q;</div><div class="line">    Matrix&lt;<span class="keyword">float</span>, N, N&gt; R;</div><div class="line">    Matrix&lt;<span class="keyword">float</span>, M, M&gt; I;</div><div class="line">    Matrix&lt;<span class="keyword">float</span>, M, M&gt; F;</div><div class="line">    Matrix&lt;<span class="keyword">float</span>, N, M&gt; H;</div><div class="line"></div><div class="line">    Matrix&lt;<span class="keyword">float</span>, M, <span class="number">1</span>&gt; X;</div><div class="line">    Matrix&lt;<span class="keyword">float</span>, N, <span class="number">1</span>&gt; Z;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    Matrix&lt;<span class="keyword">float</span>, N, <span class="number">1</span>&gt; Y;</div><div class="line">    Matrix&lt;<span class="keyword">float</span>, N, N&gt; S;</div><div class="line">    Matrix&lt;<span class="keyword">float</span>, N, N&gt; S_inv;</div><div class="line">    Matrix&lt;<span class="keyword">float</span>, M, N&gt; K;</div><div class="line"></div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_P</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">float</span> value)</span> </span>&#123; P(m, n) = value; &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_Q</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">float</span> value)</span> </span>&#123; Q(m, n) = value; &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_R</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">float</span> value)</span> </span>&#123; R(m, n) = value; &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_I</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">float</span> value)</span> </span>&#123; I(m, n) = value; &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_F</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">float</span> value)</span> </span>&#123; F(m, n) = value; &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_H</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">float</span> value)</span> </span>&#123; H(m, n) = value; &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_X</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">float</span> value)</span> </span>&#123; X(m, n) = value; &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_Z</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">float</span> value)</span> </span>&#123; Z(m, n) = value; &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_X</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> X(m, n); &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">predict</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">correct</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> M, <span class="keyword">int</span> N&gt;</div><div class="line"><span class="keyword">void</span> ekf&lt;M, N&gt;::predict()</div><div class="line">&#123;</div><div class="line"></div><div class="line">    X = F * X;</div><div class="line"></div><div class="line">    P = F * P * F.transpose() + Q;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> M, <span class="keyword">int</span> N&gt;</div><div class="line"><span class="keyword">void</span> ekf&lt;M, N&gt;::correct()</div><div class="line">&#123;</div><div class="line"></div><div class="line">    Y = Z - H * X;</div><div class="line"></div><div class="line">    S = H * P * H.transpose() + R;</div><div class="line"></div><div class="line"><span class="comment">//    &amp;S_inv = inverse&lt;n&gt;(&amp;S);</span></div><div class="line"></div><div class="line">    K = P * H.transpose() * S_inv;</div><div class="line"></div><div class="line">    X = X + (K * Y);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://owsesa4hj.bkt.clouddn.com/publications1.jpg&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="quadcopter" scheme="https://lqucool.github.io/categories/quadcopter/"/>
    
    
      <category term="quadcopter" scheme="https://lqucool.github.io/tags/quadcopter/"/>
    
      <category term="height fusion" scheme="https://lqucool.github.io/tags/height-fusion/"/>
    
  </entry>
  
</feed>
