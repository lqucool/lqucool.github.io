{"meta":{"title":"Make the ideas fly","subtitle":null,"description":"Stay Hungry, Stay Foolish.","author":"Qu.L","url":"https://lqucool.github.io"},"pages":[{"title":"nothing about me","date":"2017-10-12T14:09:51.000Z","updated":"2017-11-13T13:56:27.671Z","comments":true,"path":"about/index.html","permalink":"https://lqucool.github.io/about/index.html","excerpt":"","text":"Uh huh ~~~"},{"title":"","date":"2017-10-11T14:13:53.000Z","updated":"2017-10-12T14:14:42.910Z","comments":true,"path":"categories/index.html","permalink":"https://lqucool.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-10-11T13:52:58.000Z","updated":"2017-10-12T14:14:59.226Z","comments":true,"path":"tags/index.html","permalink":"https://lqucool.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LocalPositionEstimator","slug":"LocalPositionEstimator","date":"2018-03-13T16:00:00.000Z","updated":"2018-03-13T16:00:00.000Z","comments":true,"path":"2018/03/14/LocalPositionEstimator/","link":"","permalink":"https://lqucool.github.io/2018/03/14/LocalPositionEstimator/","excerpt":"","text":"Sensorsinput: ax, ay, az (acceleration NED) states: px, py, pz ( position NED, m) vx, vy, vz ( vel NED, m/s) bx, by, bz ( accel bias, m/s^2) tz (terrain altitude, ASL, m) measurements: sonar: pz (measured dcos(phi)cos(theta)) baro: pz flow: vx, vy (flow is in body x, y frame) gps: px, py, pz, vx, vy, vz (flow is in body x, y frame) lidar: pz (actual measured dcos(phi)cos(theta)) vision: px, py, pz, vx, vy, vz mocap: px, py, pz land (detects when landed)): pz (always measures agl = 0) Continuous-time extended Kalman filterprediction \\begin{align} &\\dot{x}_{(+|-)} = A*x_{(-|-)} + B*u_{(+)} \\\\ &\\dot{P}_{(+|-)} = A*P_{(-|-)}*A^T + B*R_{acc}*B^T + Q \\end{align}correction \\begin{align} &K_i = P_{(+|-)} * C^T * (C * P_{(+|-)} * C^T + R_{sensor})^{-1} \\\\ &x_{(+|+)} = x_{(+|-)} + K_i * (y_i - C_i * x_{(+|-)} ) \\\\ &P_{(+|+)} = (I - K_i * C) * P_{(+|-)} \\end{align} detect distance sensors see which updates are available get new data update parameters is xy valid? is z valid? is terrain valid? check timeouts reinitialize x if necessary force P symmetry and reinitialize P if necessary Predict x: \\left[ \\begin{array}{cccc} x \\\\ y \\\\ z \\\\ vx \\\\ vy \\\\ vz \\\\ bx \\\\ by \\\\ bz \\\\ tz \\\\ \\end{array} \\right] \\qquad u: \\left[ \\begin{array}{cccc} a_{x\\_{ned}} \\\\ a_{y\\_{ned}} \\\\ a_{z\\_{ned}} \\\\ \\end{array} \\right] A: \\left[ \\begin{array}{cccc} 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & _{-R_{att(0,0)}} & _{-R_{att(0,1)}} & _{-R_{att(0,2)}} & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & _{-R_{att(1,0)}} & _{-R_{att(1,1)}} & _{-R_{att(1,2)}} & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & _{-R_{att(2,0)}} & _{-R_{att(2,1)}} & _{-R_{att(2,2)}} & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ \\end{array} \\right] \\qquad B: \\left[ \\begin{array}{cccc} 0 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ \\end{array} \\right] P: \\left[ \\begin{array}{cccc} 8 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 8 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 8 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0.18 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0.18 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0.18 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & 1e^{-6} & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1e^{-6} & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1e^{-6} & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 8 \\\\ \\end{array} \\right] Q: \\left[ \\begin{array}{cccc} 0.01 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0.01 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0.01 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0.01 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0.01 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0.01 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & 1e^{-6} & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1e^{-6} & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1e^{-6} & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & pt \\\\ \\end{array} \\right] R_{acc}: \\left[ \\begin{array}{cccc} 0 .12^2& 0 & 0 \\\\ 0 & 0.12^2 & 0 \\\\ 0 & 0 & 0.02^2 \\\\ \\end{array} \\right] \\begin{align} &u = \\_R\\_att * a_{body} \\\\ &u(a_{z\\_ned})= u(a_{z\\_ned}) - 9.81 \\end{align}update A: A(vx,bx) = -R_{att(0,0)} \\\\ A(vx,by) = -R_{att(0,1)} \\\\ ...integrate runge kutta 4th order: \\begin{align} &h = dt\\\\ &k1 = A * x + B * u \\\\ &k2 = A * (x + k1 * h / 2) + B * u \\\\ &k3 = A * (x + k2 * h / 2) + B * u \\\\ &k4 = A * (x + k3) + B *u \\\\ &dx = (k1 + k2 * 2 + k3 * 2 + k4) * (h /6) \\end{align}saturate bias: \\begin{align} &bx = dx(bx) + x(bx) \\\\ &bx = BIAS\\_MAX * bx / |bx| \\\\ &dx(bx) = bx - x(bx) \\end{align}propagate: \\begin{align} x &= x + dx \\\\ dP &= (A * P + P * A^T + B * R_{acc} * B^T + Q) * dt \\\\ P &= P + dP \\end{align} Correct \\begin{align} S\\_I &= (C * P * C^T + R_{sensor})^{-1} \\\\ r &= y - C * x \\\\ K &= P * C^T *S\\_I \\\\ dx &= K *r \\\\ x &= x + dx \\\\ P &= P - K * C * P \\end{align}BaroCorrect \\begin{align} y&: [z_{baro}] \\\\ R_{baro}&: [3.0^2] \\\\ C&: \\left[ \\begin{array}{cccc} 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ \\end{array} \\right] \\end{align}LidarCorrect \\begin{align} y &: [z_{lidar}] \\\\ R_{lidar}& : [0.03^2] \\\\ C&: \\left[ \\begin{array}{cccc} 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & -1 \\\\ \\end{array} \\right] \\\\ y &= y * cos(euler(0)) * cos(euler(1)) \\\\ \\end{align}FlowCorrectcomplement: pixel\\_flow\\_integral = \\frac{v *dt } {h} * scale_h + scale_{gyro} * tan(gyro\\_rate\\_integral)) check for sane pitch/roll check for agl check quality calculate range to center of image for flow optical flow in x, y axis: \\begin{align} &d = (x(z) - x(tz) ) * cos(euler(phi)) * euler(theta) \\\\ &flow\\_x\\_rad = pixel\\_flow\\_x\\_integral * scale \\\\ &flow\\_y\\_rad = pixel\\_flow\\_y\\_integral * scale \\\\ &dt\\_flow = integration\\_timespan / 1e6; \\end{align}angular rotation in x, y axis: gyro\\_x\\_rad = high\\_pass\\_flt(gyro\\_x\\_rate\\_integral) \\\\ gyro\\_y\\_rad = high\\_pass\\_flt(gyro\\_y\\_rate\\_integral) \\\\compute velocities in body frame using ground distance: delta\\_b = \\left[ \\begin{array}{cccc} +(flow\\_y\\_rad - gyro\\_y\\_rad) * d \\\\ -(flow\\_x\\_rad - gyro\\_x\\_rad) * d \\\\ 0 \\end{array} \\right] \\\\rotation of flow from body to nav frame: \\begin{align} delta\\_n &= R\\_att * delta\\_b \\\\ \\end{align} y = \\left[ \\begin{array}{cccc} delta\\_n(0) / dt\\_flow \\\\ delta\\_n(1) / dt\\_flow \\end{array} \\right] \\\\ C = \\left[ \\begin{array}{cccc} 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\end{array} \\right] \\\\ R_{flow} = \\left[ \\begin{array}{cccc} 0 & 0 \\\\ 0 & 0 \\end{array} \\right]polynomial noise model, found using least squares fit: p[5] = \\{0.04005232f, -0.00656446f, -0.26265873f, 0.13686658f, -0.00397357f\\} \\\\ h = x(z) - x(tz) \\\\ v = y.norm()compute polynomial value: \\begin{align} flow\\_vxy\\_stddev &= p[0] *h + p[1] * h * h + p[2] * v * h + p[4] * v * h * h \\\\ \\\\ rotrate\\_sq &= att.rollspeed * att.rolldspeed \\\\ &+ att.pitchspeed *att.pitchspeed \\\\ &+ att.yawspeed * att.yawspeed \\\\ \\\\ rot\\_sq &= euler(0) *euler(0) + euler(1) * euler(1) \\\\ \\\\ R_{flow}(0,0) &= flow\\_vxy\\_stddev * flow\\_vxy\\_stddev \\\\ &+ LPE\\_FLW\\_R * LPE\\_FLW\\_R * rot\\_sq\\\\ &+ LPE\\_FLW\\_RR * LPE\\_FLW\\_RR * rotrate\\_sq \\\\ R_{flow}(1,1) &= R_{flow}(0,0) \\\\ \\end{align}GpsCorrectformulas according to: http://mathworld.wolfram.com/AzimuthalEquidistantProjection.html get the orgin pos： ref\\_cos\\_lat = cos (lat) \\\\ ref\\_cos\\_lat = cos (lat) x\\_rad = x / R_{earth} \\\\ \\quad \\\\ y\\_rad = y / R_{earth} \\\\ \\quad \\\\ c = \\sqrt{x\\_rad^2 + y\\_rad^2} \\\\ \\quad \\\\ lat\\_rad = asin(cos(c) * ref\\_sin(lat) +\\frac{x\\_rad * sin(c) * ref\\_cos(lat)}{c}) \\\\ \\quad \\\\ lon\\_rad = ref\\_lon\\_rad + atan(\\frac{y\\_rad * sin(c)} {c * ref\\_cos\\_lat * cos\\_c - x\\_rad * ref\\_sin\\_lat * sin(c)}) \\\\ \\quad \\\\ gpsLatOrigin = lat\\_rad * 180 / \\pi \\\\ \\quad \\\\ gpsLonOrigin = lon\\_rad * 180 / \\pi ref\\_lat = gpsLatOrigin \\qquad ref\\_lat = gpsLatOrigin \\\\ ref\\_sin\\_lat = sin(gpsLatOrigin) \\qquad ref\\_cos\\_lat = cos(gpsLatOrigin) y_{global} = \\left[ \\begin{array}{cccc} lat*1e^{-7} \\\\ lon*1e^{-7} \\\\ alt *1e^{-3} \\\\ vel\\_n\\_m\\_s \\\\ vel\\_e\\_m\\_s \\\\ vel\\_d\\_m\\_s \\end{array} \\right] \\\\ sin\\_lat=sin(lat*1e^{-7} * \\frac{\\pi} {180} ) \\\\ cos\\_lat=cos(lat*1e^{-7} * \\frac{\\pi} {180} ) \\\\ cos\\_d\\_lon = cos(lon\\_rad - ref\\_lon\\_rad) \\\\ arg = ref\\_sin\\_lat * sin\\_lat + ref\\_cos\\_lat * lat * cos \\_d\\_lon \\\\ c = acos(arg) \\\\ k = c / sin(c) \\\\ px = k * (ref\\_cos_lat * sin\\_lat - ref\\_sin\\_lat * cos\\_lat * cos\\_d\\_lon) * R_{earth} \\\\ py = k * cos\\_lat * sin(lon\\_rad - ref\\_lon\\_rad) * R_{earth} \\\\ pz = alt - \\_gpsAltOrigin y = \\left[ \\begin{array}{cccc} px \\\\ py \\\\ pz \\\\ vel\\_n\\_m\\_s \\\\ vel\\_e\\_m\\_s \\\\ vel\\_d\\_m\\_s \\end{array} \\right] C = \\left[ \\begin{array}{cccc} 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\\\ \\end{array} \\right] \\\\ \\qquad \\\\ \\qquad \\\\ R = \\left[ \\begin{array}{cccc} 1 & 0 & 0 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 & 0 & 0 \\\\ 0 & 0 & 3^2 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0.25^2 & 0 & 0 \\\\ 0 & 0 & 0 & 0 & 0.25^2 & 0 \\\\ 0 & 0 & 0 & 0 & 0 & 0.25^2 \\\\ \\end{array} \\right] \\\\","categories":[{"name":"quadcopter","slug":"quadcopter","permalink":"https://lqucool.github.io/categories/quadcopter/"}],"tags":[{"name":"quadcopter","slug":"quadcopter","permalink":"https://lqucool.github.io/tags/quadcopter/"},{"name":"position fusion","slug":"position-fusion","permalink":"https://lqucool.github.io/tags/position-fusion/"}]},{"title":"加计震动滤波","slug":"加计震动滤波","date":"2017-11-12T16:00:00.000Z","updated":"2017-11-12T16:00:00.000Z","comments":true,"path":"2017/11/13/加计震动滤波/","link":"","permalink":"https://lqucool.github.io/2017/11/13/加计震动滤波/","excerpt":"","text":"采集加计数据，400Hz保存到SD卡 Matlab分析采集到的数据的频谱，确定滤波器参数 生成IIR滤波器参数 C++实现并在飞控平台上测试 采集飞控上滤波后的数据并和Matlab上的滤波效果对比 Matlab设计IIR滤波器 注：Matlab生成IIR滤波器参数，飞控上使用C++实现，实现效果和Matlab设计效果一致。 ​ 截止频率不一定合适，后面单独会对电机震动频率做分析，调整截止频率。 生成参数 滤波前后频谱 滤波前后曲线 飞控上的滤波效果和matlab上滤波的效果是一致的，证明滤波算法没问题。 飞控上滤波后的数据和Matlab滤波后曲线 飞控上滤波后的数据和Matlab滤波后频谱 ​ 电机震动对加计影响 电机震动引起的震动频率在20Hz ~ 30Hz之间，设置截止频率为10Hz，也不一定每一架飞机的震动频率都相同，具体测试吧。 Matlab分析数据曲线和数据频谱 滤波后效果 Matlab123456789101112131415161718192021222324252627282930313233343536373839% ············电机震动分析············% 截取起飞前的一段数据v4 = v4(9200:10000);plot(v4);hold on;% IIRFs=400; % 采样率 Hzn=2; % 阶数 Fp=10; % 通带截止频率 HzWn=Fp*2/Fs; [Bb,Ba]=butter(n,Wn,'low') % 调用MATLAB butter函数快速设计滤波器 [BH,BW]=freqz(Bb,Ba);Bf=filter(Bb,Ba,v4);plot(Bf);legend('滤波前','滤波后');title('电机转动时加计数据'); figure;% fft 滤波前n = size(v4,1)-1;Y = fft(v4, n);Ayy = (abs(Y));Ayy = Ayy / (n / 2);Ayy(1) = Ayy(1) / 2;F=(1:n - 1)*Fs/n;plot(F(1:n/2),Ayy(1:n/2));hold on;% fft 滤波后Y = fft(Bf, n);Ayy = (abs(Y));Ayy = Ayy / (n / 2);Ayy(1) = Ayy(1) / 2;F=(1:n - 1)*Fs/n;plot(F(1:n/2),Ayy(1:n/2));legend('滤波前','滤波后');title('电机转动时加计数据频谱'); % ············电机震动分析············ C - IIR 一种比较简单的实现函数，滤波器的参数只能有Matlab生成了，但是其实滤波器的参数也是可以根据频率直接用C语言生成参数的，APM飞控里的 LowPassFilter2p.cpp 有实现的方法，可以移植一下。 12345678910111213141516171819202122232425262728293031323334353637#define IIR_ORDER 2 // orderdouble InPut_IIR[IIR_ORDER + 1] = &#123;0&#125;;double OutPut_IIR[IIR_ORDER + 1] = &#123;0&#125;;// Fs:400Hz Fp:10Hzdouble b_IIR[IIR_ORDER + 1] = &#123;0.000027f, 0.000054f, 0.000027f&#125;; //bdouble a_IIR[IIR_ORDER + 1] = &#123;1.000000f, -1.985190f, 0.985299f&#125;; //adouble IIR_I_Filter(double InData)&#123; double z1, z2; short i; double OutData; short na = IIR_ORDER + 1; short nb = IIR_ORDER + 1; for (i = nb - 1; i &gt; 0; i--) &#123; InPut_IIR[i] = InPut_IIR[i - 1]; &#125; InPut_IIR[0] = InData; for (z1 = 0, i = 0; i &lt; nb; i++) &#123; z1 += InPut_IIR[i] * b_IIR[i]; &#125; for (i = na - 1; i &gt; 0; i--) &#123; OutPut_IIR[i] = OutPut_IIR[i - 1]; &#125; for (z2 = 0, i = 1; i &lt; na; i++) &#123; z2 += OutPut_IIR[i] * a_IIR[i]; &#125; OutPut_IIR[0] = z1 - z2; OutData = OutPut_IIR[0]; return OutData;&#125;","categories":[{"name":"quadcopter","slug":"quadcopter","permalink":"https://lqucool.github.io/categories/quadcopter/"}],"tags":[{"name":"quadcopter","slug":"quadcopter","permalink":"https://lqucool.github.io/tags/quadcopter/"},{"name":"height control","slug":"height-control","permalink":"https://lqucool.github.io/tags/height-control/"},{"name":"height","slug":"height","permalink":"https://lqucool.github.io/tags/height/"}]},{"title":"硬件","slug":"硬件","date":"2017-10-21T16:00:00.000Z","updated":"2017-10-21T16:00:00.000Z","comments":true,"path":"2017/10/22/硬件/","link":"","permalink":"https://lqucool.github.io/2017/10/22/硬件/","excerpt":"","text":"处理器：STM32F427VI 九轴陀螺仪：MPU9250 气压计：MS5611 LDO：LP5907 FLASH:W25Q128 USB：CP2102 隔离保护：TXS0108 RGB Miscro SD FPC外置IMU接口 UART2,UART8,UART3,UART1 IIC SPI 4 * PWM DSM2, SBUS 之前是有考虑采用STM32F7的，但是价格有点太贵了，F4处理一般的飞控还是没有问题的，留了FPC接口，后面外接独立IMU进行减震。 原理图就不贴了。花了两个晚上把线布了，双层板 除了flash芯片没有焊接外其他都已经OK了，为自己的焊工骄傲一波。。","categories":[{"name":"quadcopter","slug":"quadcopter","permalink":"https://lqucool.github.io/categories/quadcopter/"}],"tags":[{"name":"quadcopter","slug":"quadcopter","permalink":"https://lqucool.github.io/tags/quadcopter/"},{"name":"hardware","slug":"hardware","permalink":"https://lqucool.github.io/tags/hardware/"}]},{"title":"一些想法","slug":"思路","date":"2017-10-12T16:00:00.000Z","updated":"2017-10-25T16:00:00.000Z","comments":true,"path":"2017/10/13/思路/","link":"","permalink":"https://lqucool.github.io/2017/10/13/思路/","excerpt":"记录一点想法","text":"记录一点想法 一些想法室内定点定高，室内避障，这些最基础的功能。其实我觉得这更像是一个高集成度的飞控开发平台，集成了高性能飞控平台，测距传感器，光流传感器，避障传感器，通信模组，单双目视觉。这对于开发者来说，单纯的硬件就已经非常有吸引力了。 飞控算法的话，我肯定是期望朝着商品飞控的目标去做，把飞控的用户体验和飞机的灵活性做好。 我很喜欢bitcrze团队，能够一起写作专心做喜欢的事，做一些很酷的东西出来，很希望以后有机会能够朝着他们的方向去做。 室内定位方式 双目或者目：做视觉里程计或者SLAM UWB位置融合光流传感器，我个人很想尝试这种方式，一直觉得这样应该也可以做出不错的效果 mocap 一些问题 传感器减震方式，要不要独立imu模块，单独做减震 气压计的处理 算法 软件架构 操作系统 底层驱动 姿态解算 ekf, ukf, mohony互补.. 姿态控制 pid, back-step 高度解算 kf, ukf, 互补, px4算法 高度控制 pid 油门控制方式 手动起飞算法 手动降落算法 自动起飞 自动降落 气压计和测距的切换 地形跟随模式 落地检测 位置解算 ekf, ukf 位置控制 pid 自适应 最优路径生成 路径跟随算法 避障算法 空翻 交互 视觉交互 ​ 硬件和一些结构后面再针对硬件电路分析单独写一个文章吧 机架 电机 电调 四合一电调，只有几克重 电池 遥控器接收机 飞控 体积35mm*35mm 尽量兼容px4 高级控制板（可选） 用来做飞控算法或者视觉处理 双目（可选） TOF测距 可以选用北醒的TOF测距，可以到12米远，具体需测试 Hypersen我们公司用的这家的传感器，也是TOF的，但是距离可以到30米 光流 可以采用bitcraze的开源的 淘宝有一款五十多块钱的，很便宜，过段时间买回来测试下 TOF测距避障 VL53L0X,体积超小，飞行器四面各一个，用来避障。 LED 用来灯光交互 GPS Ublox M8N 通信 2.4G数传或者wifi模组 2017.10.26 最近想了想，觉得室内飞行还是小飞机比较好些，既方便调试又方便飞行，特别是现在住的地方也不大，所以一直都在挑小飞机的硬件。 130轴距是个不错的选择，采用1106电机，6000KV，3寸碳桨，15A四合一电调，飞控自己做成30mm*30mm，再加上激光测距和光流。 1106电机 6.6g一个，四个26.4g，3020桨的时候单个电机能到300g以上最大推力，很暴力 激光测距只有5~6g中，体积也很小 光流体积20mm*20mm，也可以自己做，等飞控做稳定了还是想自己做光流和TOF模块 电池可以用2S或者3S的520mah，14500电池看起来也可以，就是不知道重量合适不合适 等发了工资要找机会整一套，还有好多工具需要啊，风枪、焊台、调试夹、放大镜、电子秤。。。还需要一套螺丝刀，之前的这些装备毕业的时候全都送人了 还有好多论文需要一个个去研究： 关于姿态解算的论文，px4的论文，bitcraze的论文，还有ETH的一些论文，路径生成和控制的论文。。。慢慢啃吧","categories":[{"name":"quadcopter","slug":"quadcopter","permalink":"https://lqucool.github.io/categories/quadcopter/"}],"tags":[{"name":"quadcopter","slug":"quadcopter","permalink":"https://lqucool.github.io/tags/quadcopter/"},{"name":"ideas","slug":"ideas","permalink":"https://lqucool.github.io/tags/ideas/"}]},{"title":"位置控制-px4","slug":"位置控制-px4","date":"2017-10-11T16:00:00.000Z","updated":"2017-10-11T16:00:00.000Z","comments":true,"path":"2017/10/12/位置控制-px4/","link":"","permalink":"https://lqucool.github.io/2017/10/12/位置控制-px4/","excerpt":"主要分析px4的位置控制方式，源码位于mc_pos_control.cpp文件 未完待续！","text":"主要分析px4的位置控制方式，源码位于mc_pos_control.cpp文件 未完待续！ 思路 todo 框架 todo 实现 todo","categories":[{"name":"quadcopter","slug":"quadcopter","permalink":"https://lqucool.github.io/categories/quadcopter/"}],"tags":[{"name":"quadcopter","slug":"quadcopter","permalink":"https://lqucool.github.io/tags/quadcopter/"},{"name":"position control","slug":"position-control","permalink":"https://lqucool.github.io/tags/position-control/"}]},{"title":"高度控制","slug":"高度控制","date":"2017-10-11T16:00:00.000Z","updated":"2017-10-21T16:00:00.000Z","comments":true,"path":"2017/10/12/高度控制/","link":"","permalink":"https://lqucool.github.io/2017/10/12/高度控制/","excerpt":"思路关于高度控制有两种不同的控制方式： 遥控器油门代表期望速度，回中代表期望速度为0，油门向上期望速度为正，油门向下期望速度为负。油门推进时，高度环只有速度环，位置环不起作用。油门回中，期望速度为0，此时飞行器悬停，位置环和速度环嵌套。 notice:油门回中时，期望速度即为0，但是实际速度并不会立即为0，由于速度环的作用，实际速度会逐渐减为0.如果在油门回中时也就是期望速度为0时，立即锁定当前高度，则飞行器会先上升一段高度，等到实际速度减为0，再下降悬停到锁定的高度，也就是油门回中时的高度。这种方式用户体验并不是很好，会给人一种很不稳的感觉。所以更好的应该是油门回中之后，飞行器应该悬停在实际飞行速度减为0的时候的高度而不是油门回中时的高度。","text":"思路关于高度控制有两种不同的控制方式： 遥控器油门代表期望速度，回中代表期望速度为0，油门向上期望速度为正，油门向下期望速度为负。油门推进时，高度环只有速度环，位置环不起作用。油门回中，期望速度为0，此时飞行器悬停，位置环和速度环嵌套。 notice:油门回中时，期望速度即为0，但是实际速度并不会立即为0，由于速度环的作用，实际速度会逐渐减为0.如果在油门回中时也就是期望速度为0时，立即锁定当前高度，则飞行器会先上升一段高度，等到实际速度减为0，再下降悬停到锁定的高度，也就是油门回中时的高度。这种方式用户体验并不是很好，会给人一种很不稳的感觉。所以更好的应该是油门回中之后，飞行器应该悬停在实际飞行速度减为0的时候的高度而不是油门回中时的高度。 遥控器油门还是代表期望速度，但是把期望速度积分得出期望位置。油门不回中时，期望速度不为0，积分后期望位置在不停更新，油门推进时由位置环和速度环嵌套。油门回中时，期望速度为0，积分后的期望位置不发生改变，飞行器即悬停。 其实两种方式不同的地方就是第一种推油门的时候是控的目标速度，只有速度环，第二种推油门的时候就是控的目标位置，位置环和速度环嵌套。 想要获得比较好的效果，问题还是有很多的： 高度的PID控制器一般都有三环，位置环-&gt;速度环-&gt;加速度环，PID想要比较好的效果需要有几点注意的地方，比如系统的延时，数据的更新频率，以及数据的精度。 激光测距的更新频率比较慢，一般就20Hz~100Hz之间，要想比较好的效果的话这种控制频率就有点慢了，所以激光的数据还是要和加计的数据进行融合，融合了加计之后可以提高一些响应速度，但是肯定也会引入一定的噪声。所以在融合的时候要在响应速度和数据的波动上做一些处理，达到最好效果。 框架 todo:待补充 实现 todo:待完善 控制目标速度123456789101112131415161718192021222324252627float _dst_vel_z; // destination velocityfloat _est_vel_z; // estimate velocityfloat _dst_pos_z; // destination positionfloat _est_pos_z; // estimate positionbool _dst_pos_z_locked; // calc desired pos_z by velocity_zif ( fabsf( _dst_vel_z ) &lt; 5 ) &#123; // usr wanna stop if ( fabsf( _est_vel_z ) &lt; 15 ) &#123; // craft is slow enough if ( !_dst_pos_z_locked ) &#123; // pos_z not fixed _dst_pos_z = _est_pos_z; _dst_pos_z_locked = true; &#125; &#125;else&#123; // craft is fast。这里有一个风险：永远控不到较小的速度，位移环就一直不起作用 if ( !_dst_pos_z_locked ) &#123; // craft is fast, but not fixed now, ctrl speed until slow enough _dst_pos_z = _est_pos_z; &#125; //else&#123; // else craft is speed up by extern force( wind, sudden turn-around. etc... ) // desired position should still hold( but maybe changed when difference is too large ) //&#125; &#125;&#125;else&#123; // users wanna move _dst_pos_z = _est_pos_z; _dst_pos_z_locked = false;&#125;","categories":[{"name":"quadcopter","slug":"quadcopter","permalink":"https://lqucool.github.io/categories/quadcopter/"}],"tags":[{"name":"quadcopter","slug":"quadcopter","permalink":"https://lqucool.github.io/tags/quadcopter/"},{"name":"height control","slug":"height-control","permalink":"https://lqucool.github.io/tags/height-control/"},{"name":"height","slug":"height","permalink":"https://lqucool.github.io/tags/height/"}]},{"title":"BeagleBone Blue 编译部署","slug":"Beaglebone 编译部署","date":"2017-10-08T16:00:00.000Z","updated":"2017-10-09T16:00:00.000Z","comments":true,"path":"2017/10/09/Beaglebone 编译部署/","link":"","permalink":"https://lqucool.github.io/2017/10/09/Beaglebone 编译部署/","excerpt":"","text":"Beaglebone blue 搭载Debian系统，今天查了下资料大概了解了开发步骤。主要有以下几种方式： PC上使用VS Code或者Sublime 进行代码编辑，之后使用WinSCP部署到Beaglebone上，在Beaglebone上使用makefile进行编译。也是比较高效的一种方法吧。 Visual Studio 2017 可以进行linux嵌入式开发了，可以直接在PC上编译生成可执行文件，然后直接在线debug，非常方便。但是我用Visual Studio的时候，一些linux头文件找不到，还有一些beaglebone的API头文件缺失，一直没有编译成功，可能是我方法有问题，这个后面有时间在解决。不过Hello World还是可以运行成功的。 还有很多开发者是在linux上使用esplice或者Qt Creator再加上交叉编译工具进行开发的，也是可以直接运行部署到beaglebone上的，不过这种方法我并没有进行尝试。 还是先记录下第一种方法怎么操作的： 下载安装WinSCP2.填入Beaglebone的主机名，端口号，还有用户名和密码，点击登录即可。登录之后的界面：左边是PC的文件目录，右边是Beaglebone的文件目录，如果要复制文件直接拖过去就行了，挺方便的。 3.在/home/debian文件夹中新建BeaglePilot文件夹，存放我们的工程项目。把我们在PC上写好的.c和Makefile直接拖过来。 4.在Putty或者WinSCP直接打开一个终端进入BeaglePilot目录，ls会看到我们刚拖进来的两个文件，然后make BeaglePilot编译生成可执行文件，这时候再ls就会看到生成的.o文件了，sudo ./BeaglePilot命令之后输入密码就可以执行我们的代码了。 这样就可以直接在PC上用自己熟悉的编辑器写完代码，部署到Beaglebone上面，直接Make，然后执行，非常方便。 后面有时间还是研究下后面两种调试方式吧，看下哪种更高效一些，接下来就可以快速验证自己的算法了。","categories":[{"name":"beaglebone","slug":"beaglebone","permalink":"https://lqucool.github.io/categories/beaglebone/"}],"tags":[{"name":"beaglebone","slug":"beaglebone","permalink":"https://lqucool.github.io/tags/beaglebone/"}]},{"title":"高度融合","slug":"高度融合","date":"2017-09-23T16:00:00.000Z","updated":"2017-10-14T16:00:00.000Z","comments":true,"path":"2017/09/24/高度融合/","link":"","permalink":"https://lqucool.github.io/2017/09/24/高度融合/","excerpt":"","text":"KF融合公式卡尔曼算法最重要的就是状态方程和转移方程的建立了，会直接影响到最终数据融合的效果。整个算法过程分为两个部分，预测和矫正： Predict: Predicted (a priori) state estimate: \\hat{x}_{k|k-1} = F_kx_{k-1|k-1} + B_ku_k Predicted (a priori) estimate covariance: P_{k|k-1} = F_kP_{k-1|k-1}F^T_{k} + Q_kUpdate: Innovation or measurement pre-fit residual: \\widetilde{y}_k = z_k - H_k\\hat{x}_{k|k-1} Innovation (or pre-fit residual) covariance: S_k = R_k + H_kP_{k|k-1}H^T_k Optimal Kalman gain: K_k = P_{k|k-1}H^T_kS^{-1}_k Updated (a posteriori) state estimate: \\hat{x}_{k|k} = \\hat{x}_{k|k-1}+ K_k\\widetilde{y}_k Updated (a posteriori) estimate covariance: P_{k|k-1} = (I - K_kH_k)P_{k|k-1} Measurement post-fit residual: \\widetilde{y}_{k|k} = z_k - H_k\\hat{x}_{k|k}状态方程 x = \\left[ \\begin{array}{ccc} h \\\\\\ v \\\\\\ a \\end{array} \\right] \\\\\\ \\\\\\ F = \\left[ \\begin{array}{ccc} 1 & t & 0 \\\\\\ 0 & 1 & t \\\\\\ 0 & 0 & 1 \\end{array} \\right] \\\\\\ \\\\\\ Z = \\left[ \\begin{array}{ccc} h_{baro} \\\\\\ acc_{ned} \\end{array} \\right]\\\\\\ \\\\\\ H = \\left[ \\begin{array}{ccc} 1 & 0 & 0 \\\\\\ 0 & 0 & 1 \\end{array} \\right]即 \\left[ \\begin{array}{ccc} h+vt \\\\\\ v+at \\\\\\ a \\end{array} \\right] = \\left[ \\begin{array}{ccc} 1 & t & 0 \\\\\\ 0 & 1 & t \\\\\\ 0 & 0 & 1 \\end{array} \\right]\\left[ \\begin{array}{ccc} h \\\\\\ v \\\\\\ a \\end{array} \\right]\\\\\\ \\\\\\ \\left[ \\begin{array}{ccc} h_{err} \\\\\\ acc_{err} \\end{array} \\right]= \\left[ \\begin{array}{ccc} h_{baro} \\\\\\ acc_{ned} \\end{array} \\right] - \\left[ \\begin{array}{ccc} 1 & 0 & 0 \\\\\\ 0 & 0 & 1 \\end{array} \\right] \\left[ \\begin{array}{ccc} h \\\\\\ v \\\\\\ a \\end{array} \\right]设置参数 P = \\left[ \\begin{array}{ccc} 0 & t & 60 \\\\\\ 1 & 1 & 3 \\\\\\ 2 & 2 & 0.1 \\end{array} \\right] \\\\\\ \\\\\\ Q = \\left[ \\begin{array}{ccc} 0.0000001 & 0 & 0 \\\\\\ 0 & 0.000005 & 0 \\\\\\ 0 & 0 & 0.05 \\end{array} \\right] \\\\\\ \\\\\\ R = \\left[ \\begin{array}{ccc} 0 & 0 & 15000 \\\\\\ 0 & 0 & 200 \\end{array} \\right] \\\\\\ \\\\\\ I = \\left[ \\begin{array}{ccc} 0 & 0 & 0 \\\\\\ 0 & 1 & 0 \\\\\\ 0 & 0 & 1 \\end{array} \\right] \\\\\\关于R和Q矩阵参数的设置需要一起调试，Q越小越相信预测值，R越小越相信测量值，两个值相互影响，最优参数不唯一的，根据实际情况调试，调试时可以先观测输出的加速度曲线，因为速度一部分是由加速度积分得到的，如果加速度都有问题的话速度的效果肯定也不会好，同理接着调试速度的参数，最后调试高度的参数。 测量值其实就是输入的气压计高度，预测值的话则是加计积分和气压计高度融合得来的。 过于相信预测值的话，也就是Q过小或者R过大，会造成收敛速度过慢，同时由于预测值是由加速度积分来的，所以飞机的震动会对加速度造成影响，也会对融合的输出值造成比较大影响，其次，如果在刚上电时加速度计有偏移，则会对融合的输出值产生很大影响，如果这个时候Q过小或者R过大，很有可能造成收敛时间特别长，虽然最后也能够收敛。 如果过于相信测量值的话，由于气压计的噪声非常大，肯定会对输出值的平坦度造成一些影响，短时间内的数据可能不够平滑。 codekf参数123456789101112131415161718192021222324252627alt_est_kf.set_H(0, 0, 1);alt_est_kf.set_H(1, 2, 1);alt_est_kf.set_P(0, 0, 60);alt_est_kf.set_P(1, 1, 3);alt_est_kf.set_P(2, 2, 0.1f);alt_est_kf.set_Q(0, 0, 0.0000001f);alt_est_kf.set_Q(1, 1, 0.000005f);alt_est_kf.set_Q(2, 2, 0.05f);alt_est_kf.set_R(0, 0, 15000);alt_est_kf.set_R(1, 1, 200);alt_est_kf.set_F(0, 0, 1);alt_est_kf.set_F(0, 1, Ts_q);alt_est_kf.set_F(1, 1, 1);alt_est_kf.set_F(1, 2, Ts_q);alt_est_kf.set_F(2, 2, 1);alt_est_kf.set_I(0, 0, 1);alt_est_kf.set_I(1, 1, 1);alt_est_kf.set_I(2, 2, 1);alt_est_kf.set_X(0, 0, 0);alt_est_kf.set_X(1, 0, 0);alt_est_kf.set_X(2, 0, 0); kf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#ifndef __ekf_h#define __ekf_h#include \"ss_matrix_q.h\"using namespace matrix;/* * M is the number of status, N is the number of observe */template &lt;int M, int N&gt;class ekf&#123; protected: Matrix&lt;float, M, M&gt; P; Matrix&lt;float, M, M&gt; Q; Matrix&lt;float, N, N&gt; R; Matrix&lt;float, M, M&gt; I; Matrix&lt;float, M, M&gt; F; Matrix&lt;float, N, M&gt; H; Matrix&lt;float, M, 1&gt; X; Matrix&lt;float, N, 1&gt; Z; private: Matrix&lt;float, N, N&gt; S; Matrix&lt;float, M, N&gt; K; public: void set_P(int m, int n, float value) &#123; P(m, n) = value; &#125; void set_Q(int m, int n, float value) &#123; Q(m, n) = value; &#125; void set_R(int m, int n, float value) &#123; R(m, n) = value; &#125; void set_I(int m, int n, float value) &#123; I(m, n) = value; &#125; void set_F(int m, int n, float value) &#123; F(m, n) = value; &#125; void set_H(int m, int n, float value) &#123; H(m, n) = value; &#125; void set_X(int m, int n, float value) &#123; X(m, n) = value; &#125; void set_Z(int m, int n, float value) &#123; Z(m, n) = value; &#125; float get_X(int m, int n) &#123; return X(m, n); &#125; void predict(); void correct();&#125;;template &lt;int M, int N&gt;void ekf&lt;M, N&gt;::predict()&#123; X = F * X; P = F * P * F.transpose() + Q;&#125;template &lt;int M, int N&gt;void ekf&lt;M, N&gt;::correct()&#123; S = H * P * H.transpose() + R; K = P * H.transpose() * S.inverse(); X = X + K * (Z - H * X); P = (I - K * H) * P;&#125;#endif","categories":[{"name":"quadcopter","slug":"quadcopter","permalink":"https://lqucool.github.io/categories/quadcopter/"}],"tags":[{"name":"quadcopter","slug":"quadcopter","permalink":"https://lqucool.github.io/tags/quadcopter/"},{"name":"height","slug":"height","permalink":"https://lqucool.github.io/tags/height/"},{"name":"height fusion","slug":"height-fusion","permalink":"https://lqucool.github.io/tags/height-fusion/"}]}]}