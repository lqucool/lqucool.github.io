{"meta":{"title":"Qu's Blog","subtitle":null,"description":null,"author":"Qu.L","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"高度融合","slug":"高度融合","date":"2017-09-24T14:32:43.911Z","updated":"2017-10-08T14:42:31.270Z","comments":true,"path":"2017/09/24/高度融合/","link":"","permalink":"http://yoursite.com/2017/09/24/高度融合/","excerpt":"","text":"思路 在进行数据融合之前，先看下能得到高度信息的传感器都有哪些： 1.气压计：在没有超声波，激光测距等传感器的时候，算是比较可靠的一个传感器了，但是其效果也就是仅仅能用，想要比较好的效果的话还是要超声波或激光的。气压计目前比较好的精度也就是10cm，的确上下移动10cm也会有效果，但是其噪声实在太大，噪声波动一般都在50cm+，所以一般都会融合加计，融合的算法有很多种，融合之后的效果在短时间内还可以接受，可以控制在5-10cm左右，但是长时间，比如静止放置十分钟或者更久，就会产生比较大的漂移，一般都会漂出去半米远，所以只用气压计融合加计并不能做出一个特别好的定高效果。 2.加计，加计的数据要是姿态解算之后的数据，也就是大地坐标系下z轴加速度计数据， 算法 1.互补滤波，应该是比较简单的一种算法。把气压计得出的高度数据微分得出速度，加计积分也得出速度，之后相互融合。 2.ekf，也就是扩展卡尔曼了，不过由于高度的状态方程是线性的，所以kf和ekf也就差别不大，ekf的算法关键的就是状态转移方程的建立了，不同的状态方程最后得出的效果也会略有区别，当然调参的小技巧可能也会不大一样，不过重点都是Q,R的参数调试。 3.还有一种处理方式就是px4中最开始使用的一种算法，其实也是预测-校验的一种思路，只不过比ekf要简单一些。 #ifndef __ekf_h #define __ekf_h #include &quot;matrix.h&quot; #include &quot;inverse.h&quot; using namespace matrix; template &lt;int M, int N&gt; class ekf { protected: Matrix&lt;float, M, M&gt; P; Matrix&lt;float, M, M&gt; Q; Matrix&lt;float, N, N&gt; R; Matrix&lt;float, M, M&gt; I; Matrix&lt;float, M, M&gt; F; Matrix&lt;float, N, M&gt; H; Matrix&lt;float, M, 1&gt; X; Matrix&lt;float, N, 1&gt; Z; private: Matrix&lt;float, N, 1&gt; Y; Matrix&lt;float, N, N&gt; S; Matrix&lt;float, N, N&gt; S_inv; Matrix&lt;float, M, N&gt; K; public: void set_P(int m, int n, float value) { P(m, n) = value; } void set_Q(int m, int n, float value) { Q(m, n) = value; } void set_R(int m, int n, float value) { R(m, n) = value; } void set_I(int m, int n, float value) { I(m, n) = value; } void set_F(int m, int n, float value) { F(m, n) = value; } void set_H(int m, int n, float value) { H(m, n) = value; } void set_X(int m, int n, float value) { X(m, n) = value; } void set_Z(int m, int n, float value) { Z(m, n) = value; } void get_X(int m, int n) { return X(m, n); } void predict(); void correct(); }; template &lt;int M, int N&gt; void ekf&lt;M, N&gt;::predict() { X = F * X; P = F * P * F.transpose() + Q; } template &lt;int M, int N&gt; void ekf&lt;M, N&gt;::correct() { Y = Z - H * X; S = H * P * H.transpose() + R; // &amp;S_inv = inverse&lt;n&gt;(&amp;S); K = P * H.transpose() * S_inv; X = X + (K * Y); } #endif","categories":[{"name":"quadcopter","slug":"quadcopter","permalink":"http://yoursite.com/categories/quadcopter/"}],"tags":[{"name":"quadcopter","slug":"quadcopter","permalink":"http://yoursite.com/tags/quadcopter/"}]}]}