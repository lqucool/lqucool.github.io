{"meta":{"title":"Make the ideas fly","subtitle":null,"description":"Stay Hungry, Stay Foolish.","author":"Qu.L","url":"https://lqucool.github.io"},"pages":[{"title":"nothing about me","date":"2017-10-12T14:09:51.000Z","updated":"2017-10-12T14:36:28.761Z","comments":true,"path":"about/index.html","permalink":"https://lqucool.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2017-10-11T14:13:53.000Z","updated":"2017-10-12T14:14:42.910Z","comments":true,"path":"categories/index.html","permalink":"https://lqucool.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-10-11T13:52:58.000Z","updated":"2017-10-12T14:14:59.226Z","comments":true,"path":"tags/index.html","permalink":"https://lqucool.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"一些想法","slug":"思路","date":"2017-10-12T16:00:00.000Z","updated":"2017-10-12T16:00:00.000Z","comments":true,"path":"2017/10/13/思路/","link":"","permalink":"https://lqucool.github.io/2017/10/13/思路/","excerpt":"这里记录一些关于飞行器设计的一些思路和想法，也算是一些总结，会不定时的更新记录自己的一些想法。","text":"这里记录一些关于飞行器设计的一些思路和想法，也算是一些总结，会不定时的更新记录自己的一些想法。 一些想法室内定点定高，室内避障，这些最基础的功能。其实我觉得这更像是一个高集成度的飞控开发平台，集成了高性能飞控平台，测距传感器，光流传感器，避障传感器，通信模组，单双目视觉。这对于开发者来说，单纯的硬件就已经非常有吸引力了。 飞控算法的话，我肯定是期望朝着商品飞控的目标去做，把飞控的用户体验和飞机的灵活性做好。 我很喜欢bitcrze团队，能够一起写作专心做喜欢的事，做一些很酷的东西出来，很希望以后有机会能够朝着他们的方向去做。 室内定位方式 双目或者目：做视觉里程计或者SLAM UWB位置融合光流传感器，我个人很想尝试这种方式，一直觉得这样应该也可以做出不错的效果 mocap 一些问题 传感器减震方式，要不要独立imu模块，单独做减震 气压计的处理 算法 软件架构 操作系统 底层驱动 姿态解算 ekf, ukf, mohony互补.. 姿态控制 pid, back-step 高度解算 kf, ukf, 互补, px4算法 高度控制 pid 油门控制方式 手动起飞算法 手动降落算法 自动起飞 自动降落 气压计和测距的切换 地形跟随模式 落地检测 位置解算 ekf, ukf 位置控制 pid 自适应 最优路径生成 路径跟随算法 避障算法 空翻 交互 视觉交互 ​ 硬件和一些结构后面再针对硬件电路分析单独写一个文章吧 机架 电机 电调 四合一电调，只有几克重 电池 遥控器接收机 飞控 体积35mm*35mm 尽量兼容px4 高级控制板（可选） 用来做飞控算法或者视觉处理 双目（可选） TOF测距 可以选用北醒的TOF测距，可以到12米远，具体需测试 Hypersen我们公司用的这家的传感器，也是TOF的，但是距离可以到30米 光流 可以采用bitcraze的开源的 淘宝有一款五十多块钱的，很便宜，过段时间买回来测试下 TOF测距避障 VL53L0X,体积超小，飞行器四面各一个，用来避障。 LED 用来灯光交互 GPS Ublox M8N 通信 2.4G数传或者wifi模组","categories":[{"name":"quadcopter","slug":"quadcopter","permalink":"https://lqucool.github.io/categories/quadcopter/"}],"tags":[{"name":"quadcopter","slug":"quadcopter","permalink":"https://lqucool.github.io/tags/quadcopter/"},{"name":"ideas","slug":"ideas","permalink":"https://lqucool.github.io/tags/ideas/"}]},{"title":"高度控制","slug":"高度控制","date":"2017-10-11T16:00:00.000Z","updated":"2017-10-11T16:00:00.000Z","comments":true,"path":"2017/10/12/高度控制/","link":"","permalink":"https://lqucool.github.io/2017/10/12/高度控制/","excerpt":"思路关于高度控制有两种不同的控制方式： 遥控器油门代表期望速度，回中代表期望速度为0，油门向上期望速度为正，油门向下期望速度为负。油门推进时，高度环只有速度环，位置环不起作用。油门回中，期望速度为0，此时飞行器悬停，位置环和速度环嵌套。 notice:油门回中时，期望速度即为0，但是实际速度并不会立即为0，由于速度环的作用，实际速度会逐渐减为0.如果在油门回中时也就是期望速度为0时，立即锁定当前高度，则飞行器会先上升一段高度，等到实际速度减为0，再下降悬停到锁定的高度，也就是油门回中时的高度。这种方式用户体验并不是很好，会给人一种很不稳的感觉。所以更好的应该是油门回中之后，飞行器应该悬停在实际飞行速度减为0的时候的高度而不是油门回中时的高度。","text":"思路关于高度控制有两种不同的控制方式： 遥控器油门代表期望速度，回中代表期望速度为0，油门向上期望速度为正，油门向下期望速度为负。油门推进时，高度环只有速度环，位置环不起作用。油门回中，期望速度为0，此时飞行器悬停，位置环和速度环嵌套。 notice:油门回中时，期望速度即为0，但是实际速度并不会立即为0，由于速度环的作用，实际速度会逐渐减为0.如果在油门回中时也就是期望速度为0时，立即锁定当前高度，则飞行器会先上升一段高度，等到实际速度减为0，再下降悬停到锁定的高度，也就是油门回中时的高度。这种方式用户体验并不是很好，会给人一种很不稳的感觉。所以更好的应该是油门回中之后，飞行器应该悬停在实际飞行速度减为0的时候的高度而不是油门回中时的高度。 遥控器油门还是代表期望速度，但是把期望速度积分得出期望位置。油门不回中时，期望速度不为0，积分后期望位置在不停更新，油门推进时由位置环和速度环嵌套。油门回中时，期望速度为0，积分后的期望位置不发生改变，飞行器即悬停。 框架 todo:待补充 实现 todo:待完善 控制目标速度123456789101112131415161718192021222324252627float _dst_vel_z; // destination velocityfloat _est_vel_z; // estimate velocityfloat _dst_pos_z; // destination positionfloat _est_pos_z; // estimate positionbool _dst_pos_z_locked; // calc desired pos_z by velocity_zif ( fabsf( _dst_vel_z ) &lt; 5 ) &#123; // usr wanna stop if ( fabsf( _est_vel_z ) &lt; 15 ) &#123; // craft is slow enough if ( !_dst_pos_z_locked ) &#123; // pos_z not fixed _dst_pos_z = _est_pos_z; _dst_pos_z_locked = true; &#125; &#125;else&#123; // craft is fast。这里有一个风险：永远控不到较小的速度，位移环就一直不起作用 if ( !_dst_pos_z_locked ) &#123; // craft is fast, but not fixed now, ctrl speed until slow enough _dst_pos_z = _est_pos_z; &#125; //else&#123; // else craft is speed up by extern force( wind, sudden turn-around. etc... ) // desired position should still hold( but maybe changed when difference is too large ) //&#125; &#125;&#125;else&#123; // users wanna move _dst_pos_z = _est_pos_z; _dst_pos_z_locked = false;&#125;","categories":[{"name":"quadcopter","slug":"quadcopter","permalink":"https://lqucool.github.io/categories/quadcopter/"}],"tags":[{"name":"quadcopter","slug":"quadcopter","permalink":"https://lqucool.github.io/tags/quadcopter/"},{"name":"height control","slug":"height-control","permalink":"https://lqucool.github.io/tags/height-control/"}]},{"title":"位置控制-px4","slug":"位置控制-px4","date":"2017-10-11T16:00:00.000Z","updated":"2017-10-11T16:00:00.000Z","comments":true,"path":"2017/10/12/位置控制-px4/","link":"","permalink":"https://lqucool.github.io/2017/10/12/位置控制-px4/","excerpt":"主要分析px4的位置控制方式，源码位于mc_pos_control.cpp文件 未完待续！","text":"主要分析px4的位置控制方式，源码位于mc_pos_control.cpp文件 未完待续！ 思路 todo 框架 todo 实现 todo","categories":[{"name":"quadcopter","slug":"quadcopter","permalink":"https://lqucool.github.io/categories/quadcopter/"}],"tags":[{"name":"quadcopter","slug":"quadcopter","permalink":"https://lqucool.github.io/tags/quadcopter/"},{"name":"position control","slug":"position-control","permalink":"https://lqucool.github.io/tags/position-control/"}]},{"title":"BeagleBone Blue 编译部署","slug":"Beaglebone 编译部署","date":"2017-10-08T16:00:00.000Z","updated":"2017-10-09T16:00:00.000Z","comments":true,"path":"2017/10/09/Beaglebone 编译部署/","link":"","permalink":"https://lqucool.github.io/2017/10/09/Beaglebone 编译部署/","excerpt":"","text":"一直想找一款能够快速开发的，高性能的板子，挑来挑去只有beaglebone blue最为合适，虽然价格略贵。 Beaglebone blue 搭载Debian系统，之前完全没玩过嵌入式linux，所以上手还是需要一点时间，今天查了下资料大概了解了开发步骤。主要有以下几种方式： PC上使用VS Code或者Sublime 进行代码编辑，之后使用WinSCP部署到Beaglebone上，在Beaglebone上使用makefile进行编译。也是比较高效的一种方法吧。 Visual Studio 2017 可以进行linux嵌入式开发了，可以直接在PC上编译生成可执行文件，然后直接在线debug，非常方便。但是我用Visual Studio的时候，一些linux头文件找不到，还有一些beaglebone的API头文件缺失，一直没有编译成功，可能是我方法有问题，这个后面有时间在解决。不过Hello World还是可以运行成功的。 还有很多开发者是在linux上使用esplice或者Qt Creator再加上交叉编译工具进行开发的，也是可以直接运行部署到beaglebone上的，不过这种方法我并没有进行尝试。 还是先记录下第一种方法怎么操作的吧： 下载安装WinSCP2.填入Beaglebone的主机名，端口号，还有用户名和密码，点击登录即可。登录之后的界面：左边是PC的文件目录，右边是Beaglebone的文件目录，如果要复制文件直接拖过去就行了，挺方便的。 3.在/home/debian文件夹中新建BeaglePilot文件夹，存放我们的工程项目。把我们在PC上写好的.c和Makefile直接拖过来。 4.在Putty或者WinSCP直接打开一个终端进入BeaglePilot目录，ls会看到我们刚拖进来的两个文件，然后make BeaglePilot编译生成可执行文件，这时候再ls就会看到生成的.o文件了，sudo ./BeaglePilot命令之后输入密码就可以执行我们的代码了。 这样就可以直接在PC上用自己熟悉的编辑器写完代码，部署到Beaglebone上面，直接Make，然后执行，非常方便。 后面有时间还是研究下后面两种调试方式吧，看下哪种更高效一些，接下来就可以快速验证自己的算法了。","categories":[{"name":"beaglebone","slug":"beaglebone","permalink":"https://lqucool.github.io/categories/beaglebone/"}],"tags":[{"name":"beaglebone","slug":"beaglebone","permalink":"https://lqucool.github.io/tags/beaglebone/"}]},{"title":"高度融合","slug":"高度融合","date":"2017-09-23T16:00:00.000Z","updated":"2017-10-09T16:00:00.000Z","comments":true,"path":"2017/09/24/高度融合/","link":"","permalink":"https://lqucool.github.io/2017/09/24/高度融合/","excerpt":"","text":"思路数据融合所需要的传感器数据： 1.气压计：在没有超声波，激光测距等传感器的时候，算是比较可靠的一个传感器了，但是其效果也就是仅仅能用，想要比较好的效果的话还是要超声波或激光的。气压计目前比较好的精度也就是10cm，的确上下移动10cm也会有效果，但是其噪声实在太大，噪声波动一般都在50cm+，所以一般都会融合加计，融合的算法有很多种，融合之后的效果在短时间内还可以接受，可以控制在5-10cm左右，但是长时间，比如静止放置十分钟或者更久，就会产生比较大的漂移，一般都会漂出去半米远，所以只用气压计融合加计并不能做出一个特别好的定高效果。 2.加计，加计的数据要是姿态解算之后的数据，也就是大地坐标系下z轴加速度计数据，要减去重力加速度。姿态解算之后的加计噪声应该会比较小了。 3.超声波，这个我没怎么用过，但是一直感觉这玩意效果也不是很好，距离又近，一般就只有3-5米远吧，个别也有更远一些的，但是价格就贵了，发射角又大，而且非常容易受到振动和气流的影响。 4.激光传感器，激光传感器本身的价格是非常贵的，但是最近TOF测距的技术发展很快，国内已经有TOF测距可以到12米甚至更远的距离，价格也不算贵，精度是非常高，cm级的精度了，更新频率几十Hz到几百Hz的都有。 算法 1.互补滤波，应该是比较简单的一种算法。把气压计得出的高度数据微分得出速度，加计积分也得出速度，之后相互融合。 2.ekf，也就是扩展卡尔曼了，不过由于高度的状态方程是线性的，所以kf和ekf也就差别不大，ekf的算法关键的就是状态转移方程的建立了，不同的状态方程最后得出的效果也会略有区别，当然调参的小技巧可能也会不大一样，不过重点都是Q,R的参数调试。 3.还有一种处理方式就是px4中最开始使用的一种算法，其实也是预测-校验的一种思路，只不过比ekf要简单一些。 kf参数123456789101112131415161718192021222324252627alt_est_kf.set_H(0, 0, 1);alt_est_kf.set_H(1, 2, 1);alt_est_kf.set_P(0, 0, 60);alt_est_kf.set_P(1, 1, 3);alt_est_kf.set_P(2, 2, 0.1f);alt_est_kf.set_Q(0, 0, 0.0000001f);alt_est_kf.set_Q(1, 1, 0.000005f);alt_est_kf.set_Q(2, 2, 0.05f);alt_est_kf.set_R(0, 0, 15000);alt_est_kf.set_R(1, 1, 200);alt_est_kf.set_F(0, 0, 1);alt_est_kf.set_F(0, 1, Ts_q);alt_est_kf.set_F(1, 1, 1);alt_est_kf.set_F(1, 2, Ts_q);alt_est_kf.set_F(2, 2, 1);alt_est_kf.set_I(0, 0, 1);alt_est_kf.set_I(1, 1, 1);alt_est_kf.set_I(2, 2, 1);alt_est_kf.set_X(0, 0, 0);alt_est_kf.set_X(1, 0, 0);alt_est_kf.set_X(2, 0, 0); kf1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#ifndef __ekf_h#define __ekf_h#include \"ss_matrix_q.h\"using namespace matrix;/* * M is the number of status, N is the number of observe */template &lt;int M, int N&gt;class ekf&#123; protected: Matrix&lt;float, M, M&gt; P; Matrix&lt;float, M, M&gt; Q; Matrix&lt;float, N, N&gt; R; Matrix&lt;float, M, M&gt; I; Matrix&lt;float, M, M&gt; F; Matrix&lt;float, N, M&gt; H; Matrix&lt;float, M, 1&gt; X; Matrix&lt;float, N, 1&gt; Z; private: Matrix&lt;float, N, N&gt; S; Matrix&lt;float, M, N&gt; K; // Matrix&lt;float, N, 1&gt; Y; // Matrix&lt;float, N, N&gt; S_inv; public: void set_P(int m, int n, float value) &#123; P(m, n) = value; &#125; void set_Q(int m, int n, float value) &#123; Q(m, n) = value; &#125; void set_R(int m, int n, float value) &#123; R(m, n) = value; &#125; void set_I(int m, int n, float value) &#123; I(m, n) = value; &#125; void set_F(int m, int n, float value) &#123; F(m, n) = value; &#125; void set_H(int m, int n, float value) &#123; H(m, n) = value; &#125; void set_X(int m, int n, float value) &#123; X(m, n) = value; &#125; void set_Z(int m, int n, float value) &#123; Z(m, n) = value; &#125; float get_X(int m, int n) &#123; return X(m, n); &#125; void predict(); void correct();&#125;;template &lt;int M, int N&gt;void ekf&lt;M, N&gt;::predict()&#123; X = F * X; P = F * P * F.transpose() + Q;&#125;template &lt;int M, int N&gt;void ekf&lt;M, N&gt;::correct()&#123; S = H * P * H.transpose() + R; K = P * H.transpose() * S.inverse(); X = X + K * (Z - H * X); P = (I - K * H) * P;&#125;#endif 调试 todo:待补充","categories":[{"name":"quadcopter","slug":"quadcopter","permalink":"https://lqucool.github.io/categories/quadcopter/"}],"tags":[{"name":"quadcopter","slug":"quadcopter","permalink":"https://lqucool.github.io/tags/quadcopter/"},{"name":"height fusion","slug":"height-fusion","permalink":"https://lqucool.github.io/tags/height-fusion/"}]}]}