{"meta":{"title":"Let the ideas fly","subtitle":null,"description":"Stay Hungry, Stay Foolish.","author":"Qu.L","url":"https://lqucool.github.io"},"pages":[{"title":"tags","date":"2017-10-11T13:52:58.000Z","updated":"2017-10-11T13:54:46.817Z","comments":true,"path":"tags/index.html","permalink":"https://lqucool.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-10-11T14:13:53.000Z","updated":"2017-10-11T14:17:25.386Z","comments":true,"path":"categories/index.html","permalink":"https://lqucool.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"BeagleBone Blue 编译部署","slug":"Beaglebone 编译部署","date":"2017-10-08T16:00:00.000Z","updated":"2017-10-09T16:00:00.000Z","comments":true,"path":"2017/10/09/Beaglebone 编译部署/","link":"","permalink":"https://lqucool.github.io/2017/10/09/Beaglebone 编译部署/","excerpt":"","text":"一直想找一款能够快速开发的，高性能的板子，挑来挑去只有beaglebone blue最为合适，虽然价格略贵。 Beaglebone blue 搭载Debian系统，之前完全没玩过嵌入式linux，所以上手还是需要一点时间，今天查了下资料大概了解了开发步骤。主要有以下几种方式： PC上使用VS Code或者Sublime 进行代码编辑，之后使用WinSCP部署到Beaglebone上，在Beaglebone上使用makefile进行编译。也是比较高效的一种方法吧。 Visual Studio 2017 可以进行linux嵌入式开发了，可以直接在PC上编译生成可执行文件，然后直接在线debug，非常方便。但是我用Visual Studio的时候，一些linux头文件找不到，还有一些beaglebone的API头文件缺失，一直没有编译成功，可能是我方法有问题，这个后面有时间在解决。不过Hello World还是可以运行成功的。 还有很多开发者是在linux上使用esplice或者Qt Creator再加上交叉编译工具进行开发的，也是可以直接运行部署到beaglebone上的，不过这种方法我并没有进行尝试。 还是先记录下第一种方法怎么操作的吧： 下载安装WinSCP2.填入Beaglebone的主机名，端口号，还有用户名和密码，点击登录即可。登录之后的界面：左边是PC的文件目录，右边是Beaglebone的文件目录，如果要复制文件直接拖过去就行了，挺方便的。 3.在/home/debian文件夹中新建BeaglePilot文件夹，存放我们的工程项目。把我们在PC上写好的.c和Makefile直接拖过来。 4.在Putty或者WinSCP直接打开一个终端进入BeaglePilot目录，ls会看到我们刚拖进来的两个文件，然后make BeaglePilot编译生成可执行文件，这时候再ls就会看到生成的.o文件了，sudo ./BeaglePilot命令之后输入密码就可以执行我们的代码了。 这样就可以直接在PC上用自己熟悉的编辑器写完代码，部署到Beaglebone上面，直接Make，然后执行，非常方便。 后面有时间还是研究下后面两种调试方式吧，看下哪种更高效一些，接下来就可以快速验证自己的算法了。","categories":[{"name":"beagleBone","slug":"beagleBone","permalink":"https://lqucool.github.io/categories/beagleBone/"}],"tags":[{"name":"beagleBone","slug":"beagleBone","permalink":"https://lqucool.github.io/tags/beagleBone/"}]},{"title":"高度融合","slug":"高度融合","date":"2017-09-23T16:00:00.000Z","updated":"2017-10-09T16:00:00.000Z","comments":true,"path":"2017/09/24/高度融合/","link":"","permalink":"https://lqucool.github.io/2017/09/24/高度融合/","excerpt":"","text":"思路整理数据融合所需要的传感器数据： 1.气压计：在没有超声波，激光测距等传感器的时候，算是比较可靠的一个传感器了，但是其效果也就是仅仅能用，想要比较好的效果的话还是要超声波或激光的。气压计目前比较好的精度也就是10cm，的确上下移动10cm也会有效果，但是其噪声实在太大，噪声波动一般都在50cm+，所以一般都会融合加计，融合的算法有很多种，融合之后的效果在短时间内还可以接受，可以控制在5-10cm左右，但是长时间，比如静止放置十分钟或者更久，就会产生比较大的漂移，一般都会漂出去半米远，所以只用气压计融合加计并不能做出一个特别好的定高效果。 2.加计，加计的数据要是姿态解算之后的数据，也就是大地坐标系下z轴加速度计数据，要减去重力加速度。姿态解算之后的加计噪声应该会比较小了。 3.超声波，这个我没怎么用过，但是一直感觉这玩意效果也不是很好，距离又近，一般就只有3-5米远吧，个别也有更远一些的，但是价格就贵了，发射角又大，而且非常容易受到振动和气流的影响。 4.激光传感器，激光传感器本身的价格是非常贵的，但是最近TOF测距的技术发展很快，国内已经有TOF测距可以到12米甚至更远的距离，价格也不算贵，精度是非常高，cm级的精度了，更新频率几十Hz到几百Hz的都有。 算法 1.互补滤波，应该是比较简单的一种算法。把气压计得出的高度数据微分得出速度，加计积分也得出速度，之后相互融合。 2.ekf，也就是扩展卡尔曼了，不过由于高度的状态方程是线性的，所以kf和ekf也就差别不大，ekf的算法关键的就是状态转移方程的建立了，不同的状态方程最后得出的效果也会略有区别，当然调参的小技巧可能也会不大一样，不过重点都是Q,R的参数调试。 3.还有一种处理方式就是px4中最开始使用的一种算法，其实也是预测-校验的一种思路，只不过比ekf要简单一些。 ​123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#ifndef __ekf_h#define __ekf_h#include \"matrix.h\"#include \"inverse.h\"using namespace matrix;template &lt;int M, int N&gt;class ekf&#123; protected: Matrix&lt;float, M, M&gt; P; Matrix&lt;float, M, M&gt; Q; Matrix&lt;float, N, N&gt; R; Matrix&lt;float, M, M&gt; I; Matrix&lt;float, M, M&gt; F; Matrix&lt;float, N, M&gt; H; Matrix&lt;float, M, 1&gt; X; Matrix&lt;float, N, 1&gt; Z; private: Matrix&lt;float, N, 1&gt; Y; Matrix&lt;float, N, N&gt; S; Matrix&lt;float, N, N&gt; S_inv; Matrix&lt;float, M, N&gt; K; public: void set_P(int m, int n, float value) &#123; P(m, n) = value; &#125; void set_Q(int m, int n, float value) &#123; Q(m, n) = value; &#125; void set_R(int m, int n, float value) &#123; R(m, n) = value; &#125; void set_I(int m, int n, float value) &#123; I(m, n) = value; &#125; void set_F(int m, int n, float value) &#123; F(m, n) = value; &#125; void set_H(int m, int n, float value) &#123; H(m, n) = value; &#125; void set_X(int m, int n, float value) &#123; X(m, n) = value; &#125; void set_Z(int m, int n, float value) &#123; Z(m, n) = value; &#125; void get_X(int m, int n) &#123; return X(m, n); &#125; void predict(); void correct();&#125;;template &lt;int M, int N&gt;void ekf&lt;M, N&gt;::predict()&#123; X = F * X; P = F * P * F.transpose() + Q;&#125;template &lt;int M, int N&gt;void ekf&lt;M, N&gt;::correct()&#123; Y = Z - H * X; S = H * P * H.transpose() + R;// &amp;S_inv = inverse&lt;n&gt;(&amp;S); K = P * H.transpose() * S_inv; X = X + (K * Y);&#125;#endif","categories":[{"name":"quadcopter","slug":"quadcopter","permalink":"https://lqucool.github.io/categories/quadcopter/"}],"tags":[{"name":"quadcopter","slug":"quadcopter","permalink":"https://lqucool.github.io/tags/quadcopter/"},{"name":"height fusion","slug":"height-fusion","permalink":"https://lqucool.github.io/tags/height-fusion/"}]}]}